{"meta":{"title":"枫林晚秋","subtitle":null,"description":null,"author":"cuijunlei","url":"http://makeafree.github.io"},"pages":[{"title":"about","date":"2019-10-13T08:21:53.000Z","updated":"2019-10-13T08:28:34.953Z","comments":true,"path":"about/index.html","permalink":"http://makeafree.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"My Works","date":"2019-10-13T08:22:39.000Z","updated":"2019-10-13T08:22:33.008Z","comments":true,"path":"My Works/index.html","permalink":"http://makeafree.github.io/My Works/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"","slug":"Android TV  Mstar平台Audio Path及声音曲线配置","date":"2020-05-30T03:40:17.555Z","updated":"2020-05-30T03:40:17.682Z","comments":true,"path":"2020/05/30/Android TV  Mstar平台Audio Path及声音曲线配置/","link":"","permalink":"http://makeafree.github.io/2020/05/30/Android TV  Mstar平台Audio Path及声音曲线配置/","excerpt":"","text":"Android TV : Mstar平台Audio Path及声音曲线配置一、Audio Path配置 在HW 修改电路之后，SW 通常也需要重新修改匹配硬件，这样才能保证功能的正常使用。 下面以VGA 通过的line-lin 为例： 从原理图上看，VGA通道的PC audio in 是属于芯片端的pin 脚是Y3，AA4，对应的 port 是line-in 第 0 路。 mstar 平台 audio 的映射关系包含audio in，audio out，以及内部 audio mux。对应的是board.h 文件中的三个结构体： // audio-in , 右侧对应的是通道，左侧是对应的声音进入的port static AudioMux_t BOARD_AudioMux_t[BOARD_AUDIO_INPUT_SOURCE_TYPE_SIZE] = { {AUDIO_DSP1_DVB_INPUT}, //AUDIO_SOURCE_DTV {AUDIO_DSP1_DVB_INPUT}, //AUDIO_SOURCE_DTV2 {AUDIO_DSP4_SIF_INPUT}, //AUDIO_SOURCE_ATV {AUDIO_AUIN4_INPUT}, //AUDIO_SOURCE_PC {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_YPbPr {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_YPbPr2 {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_AV {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_AV2 {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_AV3 {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_SV {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_SV2 {AUDIO_AUIN4_INPUT}, //AUDIO_SOURCE_SCART {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_SCART2 {AUDIO_HDMI_INPUT}, //AUDIO_SOURCE_HDMI {AUDIO_HDMI_INPUT}, //AUDIO_SOURCE_HDMI2 {AUDIO_HDMI_INPUT}, //AUDIO_SOURCE_HDMI3 {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_DVI {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_DVI2 {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_DVI3 {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_KTV }; // audio mux，右侧对应的通道也即input source，左侧对应的是耳机/喇叭的port static AudioMux_t BOARD_AudioPath_t[BOARD_AUDIO_PATH_TYPE_SIZE] = { {AUDIO_T3_PATH_I2S}, //AUDIO_PATH_MAIN_SPEAKER {AUDIO_T3_PATH_AUOUT1}, //AUDIO_PATH_HP {AUDIO_T3_PATH_AUOUT0}, //AUDIO_PATH_LINEOUT {AUDIO_PATH_NULL}, //AUDIO_PATH_SIFOUT {AUDIO_PATH_NULL}, //AUDIO_PATH_SCART1 = SIF out {AUDIO_T3_PATH_AUOUT0}, //AUDIO_PATH_SCART2 = Lineout {AUDIO_T3_PATH_SPDIF}, //AUDIO_PATH_SPDIF {AUDIO_PATH_NULL}, //AUDIO_PATH_HDMI {AUDIO_T3_PATH_MIXER_MAIN}, // AUDIO_PATH_MIXER_MAIN {AUDIO_T3_PATH_MIXER_SECONDARY}, // AUDIO_PATH_MIXER_SECONDARY {AUDIO_PATH_NULL}, // AUDIO_PATH_7 {AUDIO_T3_PATH_MIXER_DMA_IN}, // AUDIO_PATH_MIXER_DMA_IN }; // audio-out， 是输出path 的选择 static AudioOutputType_t BOARD_AudioOutputType_t[BOARD_AUDIO_OUTPUT_TYPE_SIZE] = { {AUDIO_I2S_OUTPUT}, //AUDIO_PATH_MAIN_SPEAKER {AUDIO_AUOUT1_OUTPUT}, //AUDIO_PATH_HP {AUDIO_AUOUT0_OUTPUT}, //AUDIO_PATH_LINEOUT {AUDIO_NULL_OUTPUT}, //AUDIO_PATH_SIFOUT {AUDIO_NULL_OUTPUT}, //AUDIO_PATH_SCART1 = SIF out {AUDIO_AUOUT0_OUTPUT}, //AUDIO_PATH_SCART2 = Lineout }; 从上面的信息可以看到，line-in 里面AUDIO_AUIN0_INPUT port 对应了YPBPR，AV，DVI，DVI2，DVI3 几个通道，未看到VGA通道，配置audio in， out ，mux 信息之后，需要在系统中生效就必须初始化，设置到寄存器中去，继续查到找到三个结构体，分别保存在systeminfo模块的m_pAudioMuxInfo，m_pAudioPathInfo，m_pAudioOutputTypeInfo三个成员中，通过下面接口获取： @vendor\\mstar\\supernova\\projects\\systeminfo\\src\\SystemInfo.cpp const AudioMux_t* SystemInfo::GetAudioInputMuxInfo() { if(m_pAudioMuxInfo != NULL) { return m_pAudioMuxInfo; } ASSERT(0); } const AudioPath_t* SystemInfo::GetAudioPathInfo() { if(m_pAudioPathInfo != NULL) { return m_pAudioPathInfo; } ASSERT(0); } const AudioOutputType_t* SystemInfo::GetAudioOutputTypeInfo() { if(m_pAudioOutputTypeInfo != NULL) { return m_pAudioOutputTypeInfo; } ASSERT(0); } 接着在_InputSourceTypeToAudioInputType（vendor\\mstar\\supernova\\projects\\customization\\MStarSDK\\audio\\mapi_audio_customer.cpp）接口中获取，根据通道进行设置： static AUDIO_INPUT_TYPE _InputSourceTypeToAudioInputType(MAPI_INPUT_SOURCE_TYPE eSourceType) { const AudioMux_t* const p_AudioInputMux = mapi_syscfg_fetch::GetInstance()-&gt;GetAudioInputMuxInfo(); AUDIO_INPUT_TYPE eAudioInputType = AUDIO_NULL_INPUT; MAPI_U32 u32Port = 0xFF; switch(eSourceType) { case MAPI_INPUT_SOURCE_DTV: { u32Port = p_AudioInputMux[MAPI_AUDIO_SOURCE_DTV].u32Port; break; } ........ case MAPI_INPUT_SOURCE_YPBPR: { u32Port = p_AudioInputMux[MAPI_AUDIO_SOURCE_YPBPR].u32Port; break; } case MAPI_INPUT_SOURCE_YPBPR2: { u32Port = p_AudioInputMux[MAPI_AUDIO_SOURCE_YPBPR2].u32Port; break; } case MAPI_INPUT_SOURCE_VGA: case MAPI_INPUT_SOURCE_VGA2: case MAPI_INPUT_SOURCE_VGA3: { u32Port = p_AudioInputMux[MAPI_AUDIO_SOURCE_PC].u32Port; break; } case MAPI_INPUT_SOURCE_HDMI: case MAPI_INPUT_SOURCE_HDMI2: case MAPI_INPUT_SOURCE_HDMI3: case MAPI_INPUT_SOURCE_HDMI4: { u32Port = p_AudioInputMux[MAPI_AUDIO_SOURCE_HDMI].u32Port; break; } case MAPI_INPUT_SOURCE_DVI: { u32Port = p_AudioInputMux[MAPI_AUDIO_SOURCE_DVI].u32Port; break; } ...... } eAudioInputType = _u32PortToAudioInputType(u32Port); return eAudioInputType; } 到这里可以发现VGA，VGA2，VGA3 使用的是 audio in 结构体中的source （MAPI_AUDIO_SOURCE_PC） 对应的的port ： diff --git a/serials/MST160D_10ABQM_18443_DTMB_AH/Board.h b/serials/MST160D_10ABQM_18443_DTMB_AH/Board.h index 24b27d5..da095f1 100755 --- a/serials/MST160D_10ABQM_18443_DTMB_AH/Board.h +++ b/serials/MST160D_10ABQM_18443_DTMB_AH/Board.h @@ -820,7 +820,7 @@ static AudioMux_t BOARD_AudioMux_t[BOARD_AUDIO_INPUT_SOURCE_TYPE_SIZE] = {AUDIO_DSP1_DVB_INPUT}, //AUDIO_SOURCE_DTV {AUDIO_DSP1_DVB_INPUT}, //AUDIO_SOURCE_DTV2 {AUDIO_DSP4_SIF_INPUT}, //AUDIO_SOURCE_ATV - {AUDIO_AUIN4_INPUT}, //AUDIO_SOURCE_PC + {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_PC {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_YPbPr {AUDIO_NULL_INPUT}, //AUDIO_SOURCE_YPbPr2 {AUDIO_AUIN0_INPUT}, //AUDIO_SOURCE_AV 因此将AUDIO_AUIN4_INPUT 换成AUDIO_AUIN0_INPUT 即可。 如果 speaker 和 headphone 同一路硬件输出，优先以speaker 为主，同时AUDIO_OUTPUT_HP 的audio path 可以配置为NULL。 更多mstar 平台音频属性，音效设置详参文件：drvAUDIO_if.h，mapi_audio_datatype.h，apiAUDIO.h，mapi_audio.h，mapi_audio_customer.cpp，mapi_audio.cpp,MSrv_SSSound.cpp 二、声音曲线配置 mstar平台在配置完音频通道，调通功放后，需要调整声音曲线和声音功率。声音功率是调整音量逻辑最大值(100)时，喇叭(负载)功率的最大值，而声音曲线是音量0 ~ 100 整个区间，对应的音频输出的增益大小，所以声音功率调试也是曲线调试的一部分。 （1）增益寄存器 例如，我当前平台音频输出对应的bank 是0x112D 其中，音频输出通道有6个，如下 两个寄存器组成16 位，来完成增益值的配置。 （2）增益调整 从上面的excel表格中，可以知悉每个音频通道的增益调整的寄存器的16个bit位。接好喇叭(负载的阻值要和客户要求一样，例如；8欧姆)，播放1KHZ -12 db 的音源，接上示波器量负载电压。 最大功率调整：将电视音量调整到最大值100，再调整对应输出通道寄存器值，观察电压变化，并计算功率，达到客户要求的功率为止。 曲线调整：最大功率就是音量为100时，寄存器的增益值。接着在调整0~99区间对应的增益值。 （3）音频曲线配置 在customer_1.ini 中配置 TypeID = 5; [VolumeCurve] bEnabled = TRUE; u8Volume_Int[101] = \\ { \\ INT_LINE1, \\ INT_LINE2, \\ INT_LINE3, \\ INT_LINE4, \\ INT_LINE5, \\ INT_LINE6, \\ INT_LINE7, \\ INT_LINE8, \\ INT_LINE9, \\ INT_LINEa, \\ INT_LINEb \\ }; u8Volume_Fra[101] = \\ { \\ FRA_LINE1, \\ FRA_LINE2, \\ FRA_LINE3, \\ FRA_LINE4, \\ FRA_LINE5, \\ FRA_LINE6, \\ FRA_LINE7, \\ FRA_LINE8, \\ FRA_LINE9, \\ FRA_LINEa, \\ FRA_LINEb \\ }; 数组中的宏可以根据不同功放进行客制化参数配置，如： INT_LINE1=0x7F INT_LINE2='0x46,0x42,0x40,0x3E,0x3C,0x3a,0x38,0x36,0x34,0x32' INT_LINE3='0x30,0x2E,0x2D,0x2C,0x2B,0x2A,0x29,0x28,0x27,0x26' INT_LINE4='0x25,0x24,0x23,0x22,0x21,0x20,0x1F,0x1E,0x1E,0x1D' INT_LINE5='0x1D,0x1C,0x1C,0x1B,0x1B,0x1A,0x1A,0x19,0x19,0x18' INT_LINE6='0x18,0x17,0x17,0x16,0x16,0x15,0x15,0x15,0x14,0x14' INT_LINE7='0x14,0x14,0x13,0x13,0x13,0x13,0x12,0x12,0x12,0x12' INT_LINE8='0x11,0x11,0x11,0x11,0x10,0x10,0x10,0x10,0x0F,0x0F' INT_LINE9='0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0E,0x0E,0x0E,0x0E' INT_LINEa='0x0E,0x0E,0x0E,0x0E,0x0D,0x0D,0x0D,0x0D,0x0D,0x0D' INT_LINEb='0x0D,0x0D,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C' FRA_LINE1=0x00 FRA_LINE2='0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00' FRA_LINE3='0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00' FRA_LINE4='0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x04' FRA_LINE5='0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04' FRA_LINE6='0x00,0x04,0x00,0x04,0x00,0x04,0x02,0x00,0x06,0x04' FRA_LINE7='0x02,0x00,0x06,0x04,0x02,0x00,0x06,0x04,0x02,0x00' FRA_LINE8='0x06,0x04,0x02,0x00,0x06,0x04,0x02,0x00,0x07,0x06' FRA_LINE9='0x05,0x04,0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04' FRA_LINEa='0x03,0x02,0x01,0x00,0x07,0x06,0x05,0x04,0x03,0x02' FRA_LINEb='0x01,0x00,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00' 配置文件在 mapi_audio_customer.cpp void mapi_audio_customer::SetAbsoluteVolume(const MAPI_U8 u8Path, MAPI_U8 uPercent, const MAPI_U8 uReserve) const { MAPI_U8 TransVolum_int = 0; MAPI_U8 TransVolum_fra = 0; UNUSED(uReserve); if(uPercent &gt;= MAPI_AUDIO_VOLUME_ARRAY_NUMBER) { uPercent = MAPI_AUDIO_VOLUME_ARRAY_NUMBER - 1; printf(\"SetAbsoluteVolume: uPercent value overflow!!!\\n\"); } //check if system configuration provide customized volume curve. const VolumeCurve_t* const curve = mapi_syscfg_fetch::GetInstance()-&gt;GetVolumeCurve(); if ((curve != NULL) &amp;&amp; (curve-&gt;bEnabled == 1)) { TransVolum_int = curve-&gt;u8Volume_Int[uPercent]; TransVolum_fra = curve-&gt;u8Volume_Fra[uPercent]; } else // Use default volume table. { TransVolum_int = (MAPI_U8)(u8Volume[uPercent] &gt;&gt; 8); TransVolum_fra = (MAPI_U8)(u8Volume[uPercent] &amp; 0x00FF); } printf(\"\\nSetAbsoluteVolume: u8Path = 0x%x\\n\",u8Path); printf(\"\\nSetAbsoluteVolume: Set Volume int value = 0x%x\\n\", TransVolum_int); printf(\"\\nSetAbsoluteVolume: Set Volume fra value = 0x%x\\n\", TransVolum_fra); MApi_AUDIO_SetAbsoluteVolume(u8Path, TransVolum_int, TransVolum_fra); } 通过mapi_syscfg_fetch::GetInstance()-&gt;GetVolumeCurve()即获取ini配置声音曲线表，u8Patch 对应的就是 lineout0，lineout1，lingout2，lineout3… 最后通过MApi_AUDIO_SetAbsoluteVolume(u8Path, TransVolum_int, TransVolum_fra) 设置到主芯片寄存器： //////////////////////////////////////////////////////////////////////////////// /// @ingroup Audio_BASIC_SOUNDEFFECT /// @brief \\b Function \\b Name: MDrv_SOUND_AbsoluteVolume() /// @brief \\b Function \\b Description: This routine is used to set the absolute u8Volume of audio u8Path. /// @param u8Path \\b : for audio u8Path0 ~ u8Path6 /// @param u8Vol1 \\b : MSB 7-bit register value of 10-bit u8Volume /// range from 0x00 to 0x7E , gain: +12db to -114db (-1 db per step) /// @param u8Vol2 \\b : LSB 3-bit register value of 10-bit u8Volume /// range from 0x00 to 0x07 , gain: -0db to -0.875db (-0.125 db per step) //////////////////////////////////////////////////////////////////////////////// void MApi_AUDIO_SetAbsoluteVolume( MS_U8 u8Path, MS_U8 u8Vol1, MS_U8 u8Vol2 ); 当使用外挂混音，需要固定主芯片输出时，以下通过MApi_XC_WriteByte 直接固定了lineout0(0x112D) 这一路的输出， MAPI_U8 mapi_audio_customer::fixOutputVolumeOffset() const { #define REGADDR (0x112D00) MAPI_U8 TransVolum_int = 0; MAPI_U8 TransVolum_fra = 0; MAPI_U16 u16Temp = 0x0000; const MAPI_U16 u16Vga = 0x0c00; const MAPI_U16 u16Hdmi = 0x0400; const MAPI_U16 u16tv = 0x04c0; // atv, dtv const MAPI_U16 u16Storage = 0x0b80; const MAPI_U16 u16Cvbs = 0x0a80; if(MAPI_INPUT_SOURCE_VGA == m_mainCurInputSrc) { u16Temp = u16Vga; } else if(MAPI_INPUT_SOURCE_ATV == m_mainCurInputSrc || MAPI_INPUT_SOURCE_DTV == m_mainCurInputSrc) { u16Temp = u16tv; } else if(MAPI_INPUT_SOURCE_CVBS &lt;= m_mainCurInputSrc &amp;&amp; MAPI_INPUT_SOURCE_CVBS_MAX &gt; m_mainCurInputSrc) { u16Temp = u16Cvbs; } else if (MAPI_INPUT_SOURCE_YPBPR &lt;= m_mainCurInputSrc &amp;&amp; MAPI_INPUT_SOURCE_YPBPR_MAX &gt; m_mainCurInputSrc) { u16Temp = u16Cvbs; } else if(MAPI_INPUT_SOURCE_HDMI &lt;= m_mainCurInputSrc &amp;&amp; MAPI_INPUT_SOURCE_HDMI_MAX &gt; m_mainCurInputSrc) { u16Temp = u16Hdmi; } else if(MAPI_INPUT_SOURCE_STORAGE == m_mainCurInputSrc) { u16Temp = u16Storage; } else { return 0; } TransVolum_int = (u16Temp &gt;&gt; 8); TransVolum_fra = (u16Temp &amp; 0x00FF); printf(\"[%s][%d] fix the android output to 4.6db \\n\",__FUNCTION__,__LINE__); printf(\"[%s][%d] source id: %d, reg[0x112D].value = 0x%04x \\n\",__FUNCTION__,__LINE__,m_mainCurInputSrc,u16Temp); printf(\"[%s][%d] int: 0x%02x, fra: 0x%02x \\n\",__FUNCTION__,__LINE__,TransVolum_int,TransVolum_fra); MApi_XC_WriteByte(REGADDR , TransVolum_fra); MApi_XC_WriteByte(REGADDR + 1, TransVolum_int); return 1; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Android TV  Mstar平台 GPIO 调试","date":"2020-05-30T03:39:30.807Z","updated":"2020-05-30T03:39:30.917Z","comments":true,"path":"2020/05/30/Android TV  Mstar平台 GPIO 调试/","link":"","permalink":"http://makeafree.github.io/2020/05/30/Android TV  Mstar平台 GPIO 调试/","excerpt":"","text":"Android TV : Mstar平台 GPIO 调试1. GPIO状态cat /sys/kernel/debug/gpio 可以看到当前所有GPIO口的状态，输入输出模式，输出高/低 gpiochip0: GPIOs 0-115, gpio: gpio-0 ( |sysfs ) in hi gpio-1 ( |sysfs ) in hi gpio-2 ( |sysfs ) out lo gpio-3 ( |sysfs ) in hi gpio-4 ( |sysfs ) in hi gpio-5 ( |sysfs ) out lo gpio-6 ( |sysfs ) in hi gpio-7 ( |sysfs ) out hi gpio-8 ( |sysfs ) out lo gpio-9 ( |sysfs ) in hi gpio-10 ( |sysfs ) out hi gpio-11 ( |sysfs ) in hi gpio-12 ( |sysfs ) in hi gpio-13 ( |sysfs ) out hi gpio-14 ( |sysfs ) out hi gpio-15 ( |sysfs ) out hi gpio-16 ( |sysfs ) in hi gpio-17 ( |sysfs ) in lo gpio-18 ( |sysfs ) in lo gpio-19 ( |sysfs ) in hi gpio-20 ( |sysfs ) in lo gpio-21 ( |sysfs ) in lo gpio-22 ( |sysfs ) in hi gpio-23 ( |sysfs ) in lo gpio-24 ( |sysfs ) in lo gpio-25 ( |sysfs ) in lo gpio-26 ( |sysfs ) in lo gpio-27 ( |sysfs ) in hi gpio-28 ( |sysfs ) in hi gpio-29 ( |sysfs ) in hi gpio-30 ( |sysfs ) in hi gpio-31 ( |sysfs ) in lo gpio-32 ( |sysfs ) in hi gpio-33 ( |sysfs ) in hi gpio-34 ( |sysfs ) in lo gpio-35 ( |sysfs ) out lo gpio-36 ( |sysfs ) out lo gpio-37 ( |sysfs ) out lo gpio-38 ( |sysfs ) out lo gpio-39 ( |sysfs ) in lo gpio-40 ( |sysfs ) in hi gpio-41 ( |sysfs ) in hi gpio-42 ( |sysfs ) in hi gpio-43 ( |sysfs ) in hi gpio-44 ( |sysfs ) in lo gpio-45 ( |sysfs ) out hi gpio-46 ( |sysfs ) in hi gpio-47 ( |sysfs ) out hi gpio-48 ( |sysfs ) in hi gpio-49 ( |sysfs ) out hi gpio-50 ( |sysfs ) in hi gpio-51 ( |sysfs ) in hi gpio-52 ( |sysfs ) in lo gpio-53 ( |sysfs ) out lo gpio-54 ( |sysfs ) out hi gpio-55 ( |sysfs ) out lo gpio-56 ( |sysfs ) out hi gpio-57 ( |sysfs ) out lo gpio-58 ( |sysfs ) out hi gpio-59 ( |sysfs ) in hi gpio-60 ( |sysfs ) in hi gpio-61 ( |sysfs ) out hi gpio-64 ( |sysfs ) out hi gpio-65 ( |sysfs ) out hi gpio-66 ( |sysfs ) out hi gpio-67 ( |sysfs ) out lo gpio-68 ( |sysfs ) in hi gpio-69 ( |sysfs ) in hi gpio-70 ( |sysfs ) in hi gpio-71 ( |sysfs ) in hi gpio-72 ( |sysfs ) in hi gpio-73 ( |sysfs ) in hi gpio-74 ( |sysfs ) out lo gpio-75 ( |sysfs ) out hi gpio-76 ( |sysfs ) in hi gpio-77 ( |sysfs ) in hi gpio-78 ( |sysfs ) in hi gpio-79 ( |sysfs ) in lo gpio-80 ( |sysfs ) in hi gpio-81 ( |sysfs ) in lo gpio-82 ( |sysfs ) in lo gpio-83 ( |sysfs ) out lo gpio-84 ( |sysfs ) in lo gpio-85 ( |sysfs ) in lo gpio-86 ( |sysfs ) out hi gpio-87 ( |sysfs ) out lo gpio-88 ( |sysfs ) in hi gpio-89 ( |sysfs ) out lo gpio-90 ( |sysfs ) out lo gpio-91 ( |sysfs ) out lo gpio-92 ( |sysfs ) in hi gpio-93 ( |sysfs ) in hi gpio-94 ( |sysfs ) out hi gpio-95 ( |sysfs ) out hi gpio-96 ( |sysfs ) in lo gpio-97 ( |scl ) in hi gpio-98 ( |sda ) in hi gpio-99 ( |sysfs ) in hi gpio-100 ( |sysfs ) in hi gpio-101 ( |sysfs ) in hi gpio-102 ( |sysfs ) in lo gpio-103 ( |sysfs ) in hi gpio-104 ( |sysfs ) in hi gpio-105 ( |sysfs ) in hi gpio-106 ( |sysfs ) in hi gpio-107 ( |sysfs ) in hi gpio-108 ( |sysfs ) in hi gpio-109 ( |sysfs ) in hi gpio-110 ( |sysfs ) out lo gpio-111 ( |sysfs ) out hi gpio-112 ( |sysfs ) in hi gpio-113 ( |sysfs ) in hi gpio-114 ( |sysfs ) in hi gpio-115 ( |sysfs ) in hi 例如： GPIO74 为 输出 低电平（lo-低，hi-高） gpio-74 ( |sysfs ) out lo2. GPIO属性 以gpio-16为例： （1）direction ： IO 输入/输出模式 # cat /sys/devices/gpiochip0/gpio/gpio16/direction out（2）active_low # cat /sys/devices/gpiochip0/gpio/gpio16/active_low 0（3）value 当前电平高低 # cat /sys/devices/gpiochip0/gpio/gpio16/value 0 手动拉高： echo 1 &gt; /sys/devices/gpiochip0/gpio/gpio16/value 手动拉低： echo 0 &gt; /sys/devices/gpiochip0/gpio/gpio16/value3. reg 与 IO 映射 reg 和 pin ID映射 vendor\\mstar\\kernel\\linaro\\mstar2\\hal\\m7221\\gpio\\mhal_gpio.c #define GPIO0_PAD PAD_IRIN #define GPIO0_OEN 0x0f26, BIT0 #define GPIO0_OUT 0x0f26, BIT1 #define GPIO0_IN 0x0f26, BIT2 #define GPIO1_PAD PAD_CEC0 #define GPIO1_OEN 0x0f2a, BIT0 #define GPIO1_OUT 0x0f2a, BIT1 #define GPIO1_IN 0x0f2a, BIT2 #define GPIO2_PAD PAD_PWM_PM #define GPIO2_OEN 0x0f28, BIT0 #define GPIO2_OUT 0x0f28, BIT1 #define GPIO2_IN 0x0f28, BIT2 #define GPIO3_PAD PAD_DDCA_CK #define GPIO3_OEN 0x0494, BIT1 #define GPIO3_OUT 0x0494, BIT2 #define GPIO3_IN 0x0494, BIT0 #define GPIO4_PAD PAD_DDCA_DA #define GPIO4_OEN 0x0494, BIT5 #define GPIO4_OUT 0x0494, BIT6 #define GPIO4_IN 0x0494, BIT4 #define GPIO5_PAD PAD_GPIO0_PM #define GPIO5_OEN 0x0f00, BIT0 #define GPIO5_OUT 0x0f00, BIT1 #define GPIO5_IN 0x0f00, BIT2 #define GPIO6_PAD PAD_GPIO1_PM #define GPIO6_OEN 0x0f02, BIT0 #define GPIO6_OUT 0x0f02, BIT1 #define GPIO6_IN 0x0f02, BIT2 #define GPIO7_PAD PAD_GPIO2_PM #define GPIO7_OEN 0x0f04, BIT0 #define GPIO7_OUT 0x0f04, BIT1 #define GPIO7_IN 0x0f04, BIT2 #define GPIO8_PAD PAD_USB_CTRL #define GPIO8_OEN 0x0f06, BIT0 #define GPIO8_OUT 0x0f06, BIT1 #define GPIO8_IN 0x0f06, BIT2 #define GPIO9_PAD PAD_GPIO5_PM #define GPIO9_OEN 0x0f0a, BIT0 #define GPIO9_OUT 0x0f0a, BIT1 #define GPIO9_IN 0x0f0a, BIT2 #define GPIO10_PAD PAD_GPIO6_PM #define GPIO10_OEN 0x0f0c, BIT0 #define GPIO10_OUT 0x0f0c, BIT1 #define GPIO10_IN 0x0f0c, BIT2 #define GPIO11_PAD PAD_GPIO7_PM #define GPIO11_OEN 0x0f0e, BIT0 #define GPIO11_OUT 0x0f0e, BIT1 #define GPIO11_IN 0x0f0e, BIT2 #define GPIO12_PAD PAD_GPIO8_PM #define GPIO12_OEN 0x0f10, BIT0 #define GPIO12_OUT 0x0f10, BIT1 #define GPIO12_IN 0x0f10, BIT2 #define GPIO13_PAD PAD_GPIO9_PM #define GPIO13_OEN 0x0f12, BIT0 #define GPIO13_OUT 0x0f12, BIT1 #define GPIO13_IN 0x0f12, BIT2 #define GPIO14_PAD PAD_GPIO10_PM #define GPIO14_OEN 0x0f14, BIT0 #define GPIO14_OUT 0x0f14, BIT1 #define GPIO14_IN 0x0f14, BIT2 #define GPIO15_PAD PAD_GPIO11_PM #define GPIO15_OEN 0x0f16, BIT0 #define GPIO15_OUT 0x0f16, BIT1 #define GPIO15_IN 0x0f16, BIT2 #define GPIO16_PAD PAD_GPIO12_PM #define GPIO16_OEN 0x0f18, BIT0 #define GPIO16_OUT 0x0f18, BIT1 #define GPIO16_IN 0x0f18, BIT2 #define GPIO17_PAD PAD_HOTPLUGA #define GPIO17_OEN 0x0e4e, BIT0 #define GPIO17_OUT 0x0e4e, BIT4 #define GPIO17_IN 0x0e4f, BIT0 #define GPIO18_PAD PAD_HOTPLUGB #define GPIO18_OEN 0x0e4e, BIT1 #define GPIO18_OUT 0x0e4e, BIT5 #define GPIO18_IN 0x0e4f, BIT1 #define GPIO19_PAD PAD_HOTPLUGC #define GPIO19_OEN 0x0e4e, BIT2 #define GPIO19_OUT 0x0e4e, BIT6 #define GPIO19_IN 0x0e4f, BIT2 #define GPIO20_PAD PAD_HOTPLUGA_HDMI20_5V #define GPIO20_OEN 0x010218, BIT5 #define GPIO20_OUT 0x010218, BIT4 #define GPIO20_IN 0x010218, BIT6 #define GPIO21_PAD PAD_HOTPLUGB_HDMI20_5V #define GPIO21_OEN 0x010318, BIT5 #define GPIO21_OUT 0x010318, BIT4 #define GPIO21_IN 0x010318, BIT6 #define GPIO22_PAD PAD_HOTPLUGC_HDMI20_5V #define GPIO22_OEN 0x010418, BIT5 #define GPIO22_OUT 0x010418, BIT4 #define GPIO22_IN 0x010418, BIT6 #define GPIO23_PAD PAD_DDCDA_CK #define GPIO23_OEN 0x0496, BIT1 #define GPIO23_OUT 0x0496, BIT2 #define GPIO23_IN 0x0496, BIT0 #define GPIO24_PAD PAD_DDCDA_DA #define GPIO24_OEN 0x0496, BIT5 #define GPIO24_OUT 0x0496, BIT6 #define GPIO24_IN 0x0496, BIT4 #define GPIO25_PAD PAD_DDCDB_CK #define GPIO25_OEN 0x0497, BIT1 #define GPIO25_OUT 0x0497, BIT2 #define GPIO25_IN 0x0497, BIT0 #define GPIO26_PAD PAD_DDCDB_DA #define GPIO26_OEN 0x0497, BIT5 #define GPIO26_OUT 0x0497, BIT6 #define GPIO26_IN 0x0497, BIT4 #define GPIO27_PAD PAD_DDCDC_CK #define GPIO27_OEN 0x0498, BIT1 #define GPIO27_OUT 0x0498, BIT2 #define GPIO27_IN 0x0498, BIT0 #define GPIO28_PAD PAD_DDCDC_DA #define GPIO28_OEN 0x0498, BIT5 #define GPIO28_OUT 0x0498, BIT6 #define GPIO28_IN 0x0498, BIT4 #define GPIO29_PAD PAD_SAR0 #define GPIO29_OEN 0x1423, BIT0 #define GPIO29_OUT 0x1424, BIT0 #define GPIO29_IN 0x1425, BIT0 #define GPIO30_PAD PAD_SAR1 #define GPIO30_OEN 0x1423, BIT1 #define GPIO30_OUT 0x1424, BIT1 #define GPIO30_IN 0x1425, BIT1 #define GPIO31_PAD PAD_SAR2 #define GPIO31_OEN 0x1423, BIT2 #define GPIO31_OUT 0x1424, BIT2 #define GPIO31_IN 0x1425, BIT2 #define GPIO32_PAD PAD_SAR3 #define GPIO32_OEN 0x1423, BIT3 #define GPIO32_OUT 0x1424, BIT3 #define GPIO32_IN 0x1425, BIT3 #define GPIO33_PAD PAD_SAR4 #define GPIO33_OEN 0x1423, BIT4 #define GPIO33_OUT 0x1424, BIT4 #define GPIO33_IN 0x1425, BIT4 #define GPIO34_PAD PAD_VPLUGIN #define GPIO34_OEN 0x1423, BIT5 #define GPIO34_OUT 0x1424, BIT5 #define GPIO34_IN 0x1425, BIT5 #define GPIO35_PAD PAD_VID0 #define GPIO35_OEN 0x2e84, BIT1 #define GPIO35_OUT 0x2e84, BIT0 #define GPIO35_IN 0x2e84, BIT2 #define GPIO36_PAD PAD_VID1 #define GPIO36_OEN 0x2e85, BIT1 #define GPIO36_OUT 0x2e85, BIT0 #define GPIO36_IN 0x2e85, BIT2 #define GPIO37_PAD PAD_VID2 #define GPIO37_OEN 0x0f22, BIT0 #define GPIO37_OUT 0x0f22, BIT1 #define GPIO37_IN 0x0f22, BIT2 #define GPIO38_PAD PAD_VID3 #define GPIO38_OEN 0x0f24, BIT0 #define GPIO38_OUT 0x0f24, BIT1 #define GPIO38_IN 0x0f24, BIT2 #define GPIO39_PAD PAD_WOL_INT_OUT #define GPIO39_OEN 0x2e82, BIT1 #define GPIO39_OUT 0x2e82, BIT0 #define GPIO39_IN 0x2e82, BIT2 #define GPIO40_PAD PAD_I2S_IN_BCK #define GPIO40_OEN 0x0f3e, BIT0 #define GPIO40_OUT 0x0f3e, BIT1 #define GPIO40_IN 0x0f3e, BIT2 #define GPIO41_PAD PAD_I2S_IN_WS #define GPIO41_OEN 0x0f40, BIT0 #define GPIO41_OUT 0x0f40, BIT1 #define GPIO41_IN 0x0f40, BIT2 #define GPIO42_PAD PAD_I2S_IN_MCK #define GPIO42_OEN 0x0f42, BIT0 #define GPIO42_OUT 0x0f42, BIT1 #define GPIO42_IN 0x0f42, BIT2 #define GPIO43_PAD PAD_I2S_IN_SD0 #define GPIO43_OEN 0x0f44, BIT0 #define GPIO43_OUT 0x0f44, BIT1 #define GPIO43_IN 0x0f44, BIT2 #define GPIO44_PAD PAD_I2S_IN_SD1 #define GPIO44_OEN 0x0f46, BIT0 #define GPIO44_OUT 0x0f46, BIT1 #define GPIO44_IN 0x0f46, BIT2 #define GPIO45_PAD PAD_CILINK_DEMOD0_CLK #define GPIO45_OEN 0x102b13, BIT1 #define GPIO45_OUT 0x102b13, BIT0 #define GPIO45_IN 0x102b13, BIT2 #define GPIO46_PAD PAD_CILINK_DEMOD1_CLK #define GPIO46_OEN 0x102b1a, BIT1 #define GPIO46_OUT 0x102b1a, BIT0 #define GPIO46_IN 0x102b1a, BIT2 #define GPIO47_PAD PAD_CILINK_INT #define GPIO47_OEN 0x102b12, BIT1 #define GPIO47_OUT 0x102b12, BIT0 #define GPIO47_IN 0x102b12, BIT2 #define GPIO48_PAD PAD_CILINK_RX0_D0 #define GPIO48_OEN 0x102b18, BIT1 #define GPIO48_OUT 0x102b18, BIT0 #define GPIO48_IN 0x102b18, BIT2 #define GPIO49_PAD PAD_CILINK_RX0_D1 #define GPIO49_OEN 0x102b19, BIT1 #define GPIO49_OUT 0x102b19, BIT0 #define GPIO49_IN 0x102b19, BIT2 #define GPIO50_PAD PAD_CILINK_RX1_D0 #define GPIO50_OEN 0x102ba1, BIT1 #define GPIO50_OUT 0x102ba1, BIT0 #define GPIO50_IN 0x102ba1, BIT2 #define GPIO51_PAD PAD_CILINK_RX1_D1 #define GPIO51_OEN 0x102ba2, BIT1 #define GPIO51_OUT 0x102ba2, BIT0 #define GPIO51_IN 0x102ba2, BIT2 #define GPIO52_PAD PAD_CILINK_RX_CLK #define GPIO52_OEN 0x102b17, BIT1 #define GPIO52_OUT 0x102b17, BIT0 #define GPIO52_IN 0x102b17, BIT2 #define GPIO53_PAD PAD_CILINK_SPI_CLK #define GPIO53_OEN 0x102b0e, BIT1 #define GPIO53_OUT 0x102b0e, BIT0 #define GPIO53_IN 0x102b0e, BIT2 #define GPIO54_PAD PAD_CILINK_SPI_CS #define GPIO54_OEN 0x102b11, BIT1 #define GPIO54_OUT 0x102b11, BIT0 #define GPIO54_IN 0x102b11, BIT2 #define GPIO55_PAD PAD_CILINK_SPI_MISO #define GPIO55_OEN 0x102b10, BIT1 #define GPIO55_OUT 0x102b10, BIT0 #define GPIO55_IN 0x102b10, BIT2 #define GPIO56_PAD PAD_CILINK_SPI_MOSI #define GPIO56_OEN 0x102b0f, BIT1 #define GPIO56_OUT 0x102b0f, BIT0 #define GPIO56_IN 0x102b0f, BIT2 #define GPIO57_PAD PAD_CILINK_TX0_D0 #define GPIO57_OEN 0x102b15, BIT1 #define GPIO57_OUT 0x102b15, BIT0 #define GPIO57_IN 0x102b15, BIT2 #define GPIO58_PAD PAD_CILINK_TX0_D1 #define GPIO58_OEN 0x102b16, BIT1 #define GPIO58_OUT 0x102b16, BIT0 #define GPIO58_IN 0x102b16, BIT2 #define GPIO59_PAD PAD_CILINK_TX1_D0 #define GPIO59_OEN 0x102b1b, BIT1 #define GPIO59_OUT 0x102b1b, BIT0 #define GPIO59_IN 0x102b1b, BIT2 #define GPIO60_PAD PAD_CILINK_TX1_D1 #define GPIO60_OEN 0x102ba0, BIT1 #define GPIO60_OUT 0x102ba0, BIT0 #define GPIO60_IN 0x102ba0, BIT2 #define GPIO61_PAD PAD_CILINK_TX_CLK #define GPIO61_OEN 0x102b14, BIT1 #define GPIO61_OUT 0x102b14, BIT0 #define GPIO61_IN 0x102b14, BIT2 #define GPIO62_PAD PAD_DDCR_CK #define GPIO62_OEN 0x102b87, BIT1 #define GPIO62_OUT 0x102b87, BIT0 #define GPIO62_IN 0x102b87, BIT2 #define GPIO63_PAD PAD_DDCR_DA #define GPIO63_OEN 0x102b86, BIT1 #define GPIO63_OUT 0x102b86, BIT0 #define GPIO63_IN 0x102b86, BIT2 #define GPIO64_PAD PAD_GPIO2 #define GPIO64_OEN 0x102b00, BIT1 #define GPIO64_OUT 0x102b00, BIT0 #define GPIO64_IN 0x102b00, BIT2 #define GPIO65_PAD PAD_GPIO3 #define GPIO65_OEN 0x102b01, BIT1 #define GPIO65_OUT 0x102b01, BIT0 #define GPIO65_IN 0x102b01, BIT2 #define GPIO66_PAD PAD_GPIO4 #define GPIO66_OEN 0x102b02, BIT1 #define GPIO66_OUT 0x102b02, BIT0 #define GPIO66_IN 0x102b02, BIT2 #define GPIO67_PAD PAD_GPIO5 #define GPIO67_OEN 0x102b03, BIT1 #define GPIO67_OUT 0x102b03, BIT0 #define GPIO67_IN 0x102b03, BIT2 #define GPIO68_PAD PAD_GPIO9 #define GPIO68_OEN 0x102b04, BIT1 #define GPIO68_OUT 0x102b04, BIT0 #define GPIO68_IN 0x102b04, BIT2 #define GPIO69_PAD PAD_GPIO10 #define GPIO69_OEN 0x102b05, BIT1 #define GPIO69_OUT 0x102b05, BIT0 #define GPIO69_IN 0x102b05, BIT2 #define GPIO70_PAD PAD_GPIO11 #define GPIO70_OEN 0x102b06, BIT1 #define GPIO70_OUT 0x102b06, BIT0 #define GPIO70_IN 0x102b06, BIT2 #define GPIO71_PAD PAD_GPIO12 #define GPIO71_OEN 0x102b07, BIT1 #define GPIO71_OUT 0x102b07, BIT0 #define GPIO71_IN 0x102b07, BIT2 #define GPIO72_PAD PAD_GPIO19 #define GPIO72_OEN 0x102b08, BIT1 #define GPIO72_OUT 0x102b08, BIT0 #define GPIO72_IN 0x102b08, BIT2 #define GPIO73_PAD PAD_GPIO20 #define GPIO73_OEN 0x102b09, BIT1 #define GPIO73_OUT 0x102b09, BIT0 #define GPIO73_IN 0x102b09, BIT2 #define GPIO74_PAD PAD_GPIO25 #define GPIO74_OEN 0x102b0a, BIT1 #define GPIO74_OUT 0x102b0a, BIT0 #define GPIO74_IN 0x102b0a, BIT2 #define GPIO75_PAD PAD_GPIO26 #define GPIO75_OEN 0x102b0b, BIT1 #define GPIO75_OUT 0x102b0b, BIT0 #define GPIO75_IN 0x102b0b, BIT2 #define GPIO76_PAD PAD_GPIO30 #define GPIO76_OEN 0x102b0c, BIT1 #define GPIO76_OUT 0x102b0c, BIT0 #define GPIO76_IN 0x102b0c, BIT2 #define GPIO77_PAD PAD_GPIO31 #define GPIO77_OEN 0x102b0d, BIT1 #define GPIO77_OUT 0x102b0d, BIT0 #define GPIO77_IN 0x102b0d, BIT2 #define GPIO78_PAD PAD_HDMIRX_ARCTX #define GPIO78_OEN 0x110320, BIT1 #define GPIO78_OUT 0x110320, BIT0 #define GPIO78_IN 0x110320, BIT2 #define GPIO79_PAD PAD_I2S_OUT_BCK #define GPIO79_OEN 0x102b38, BIT1 #define GPIO79_OUT 0x102b38, BIT0 #define GPIO79_IN 0x102b38, BIT2 #define GPIO80_PAD PAD_I2S_OUT_MCK #define GPIO80_OEN 0x102b39, BIT1 #define GPIO80_OUT 0x102b39, BIT0 #define GPIO80_IN 0x102b39, BIT2 #define GPIO81_PAD PAD_I2S_OUT_SD #define GPIO81_OEN 0x102b3b, BIT1 #define GPIO81_OUT 0x102b3b, BIT0 #define GPIO81_IN 0x102b3b, BIT2 #define GPIO82_PAD PAD_I2S_OUT_SD1 #define GPIO82_OEN 0x102b3c, BIT1 #define GPIO82_OUT 0x102b3c, BIT0 #define GPIO82_IN 0x102b3c, BIT2 #define GPIO83_PAD PAD_I2S_OUT_SD2 #define GPIO83_OEN 0x102b3d, BIT1 #define GPIO83_OUT 0x102b3d, BIT0 #define GPIO83_IN 0x102b3d, BIT2 #define GPIO84_PAD PAD_I2S_OUT_WS #define GPIO84_OEN 0x102b3a, BIT1 #define GPIO84_OUT 0x102b3a, BIT0 #define GPIO84_IN 0x102b3a, BIT2 #define GPIO85_PAD PAD_PWM0 #define GPIO85_OEN 0x102b88, BIT1 #define GPIO85_OUT 0x102b88, BIT0 #define GPIO85_IN 0x102b88, BIT2 #define GPIO86_PAD PAD_PWM1 #define GPIO86_OEN 0x102b89, BIT1 #define GPIO86_OUT 0x102b89, BIT0 #define GPIO86_IN 0x102b89, BIT2 #define GPIO87_PAD PAD_PWM2 #define GPIO87_OEN 0x102b8a, BIT1 #define GPIO87_OUT 0x102b8a, BIT0 #define GPIO87_IN 0x102b8a, BIT2 #define GPIO88_PAD PAD_PWM3 #define GPIO88_OEN 0x102b8b, BIT1 #define GPIO88_OUT 0x102b8b, BIT0 #define GPIO88_IN 0x102b8b, BIT2 #define GPIO89_PAD PAD_SD_CLK #define GPIO89_OEN 0x102bfa, BIT1 #define GPIO89_OUT 0x102bfa, BIT0 #define GPIO89_IN 0x102bfa, BIT2 #define GPIO90_PAD PAD_SD_CMD #define GPIO90_OEN 0x102bfb, BIT1 #define GPIO90_OUT 0x102bfb, BIT0 #define GPIO90_IN 0x102bfb, BIT2 #define GPIO91_PAD PAD_SD_D0 #define GPIO91_OEN 0x102bac, BIT1 #define GPIO91_OUT 0x102bac, BIT0 #define GPIO91_IN 0x102bac, BIT2 #define GPIO92_PAD PAD_SD_D1 #define GPIO92_OEN 0x102bad, BIT1 #define GPIO92_OUT 0x102bad, BIT0 #define GPIO92_IN 0x102bad, BIT2 #define GPIO93_PAD PAD_SD_D2 #define GPIO93_OEN 0x102bae, BIT1 #define GPIO93_OUT 0x102bae, BIT0 #define GPIO93_IN 0x102bae, BIT2 #define GPIO94_PAD PAD_SD_D3 #define GPIO94_OEN 0x102bf9, BIT1 #define GPIO94_OUT 0x102bf9, BIT0 #define GPIO94_IN 0x102bf9, BIT2 #define GPIO95_PAD PAD_SPDIF_IN #define GPIO95_OEN 0x102b36, BIT1 #define GPIO95_OUT 0x102b36, BIT0 #define GPIO95_IN 0x102b36, BIT2 #define GPIO96_PAD PAD_SPDIF_OUT #define GPIO96_OEN 0x102b37, BIT1 #define GPIO96_OUT 0x102b37, BIT0 #define GPIO96_IN 0x102b37, BIT2 #define GPIO97_PAD PAD_TGPIO0 #define GPIO97_OEN 0x102b8d, BIT1 #define GPIO97_OUT 0x102b8d, BIT0 #define GPIO97_IN 0x102b8d, BIT2 #define GPIO98_PAD PAD_TGPIO1 #define GPIO98_OEN 0x102b8e, BIT1 #define GPIO98_OUT 0x102b8e, BIT0 #define GPIO98_IN 0x102b8e, BIT2 #define GPIO99_PAD PAD_TGPIO2 #define GPIO99_OEN 0x102b8f, BIT1 #define GPIO99_OUT 0x102b8f, BIT0 #define GPIO99_IN 0x102b8f, BIT2 #define GPIO100_PAD PAD_TGPIO3 #define GPIO100_OEN 0x102b90, BIT1 #define GPIO100_OUT 0x102b90, BIT0 #define GPIO100_IN 0x102b90, BIT2 #define GPIO101_PAD PAD_TS1_CLK #define GPIO101_OEN 0x102b27, BIT1 #define GPIO101_OUT 0x102b27, BIT0 #define GPIO101_IN 0x102b27, BIT2 #define GPIO102_PAD PAD_TS1_D0 #define GPIO102_OEN 0x102b31, BIT1 #define GPIO102_OUT 0x102b31, BIT0 #define GPIO102_IN 0x102b31, BIT2 #define GPIO103_PAD PAD_TS1_D1 #define GPIO103_OEN 0x102b30, BIT1 #define GPIO103_OUT 0x102b30, BIT0 #define GPIO103_IN 0x102b30, BIT2 #define GPIO104_PAD PAD_TS1_D2 #define GPIO104_OEN 0x102b2f, BIT1 #define GPIO104_OUT 0x102b2f, BIT0 #define GPIO104_IN 0x102b2f, BIT2 #define GPIO105_PAD PAD_TS1_D3 #define GPIO105_OEN 0x102b2e, BIT1 #define GPIO105_OUT 0x102b2e, BIT0 #define GPIO105_IN 0x102b2e, BIT2 #define GPIO106_PAD PAD_TS1_D4 #define GPIO106_OEN 0x102b2d, BIT1 #define GPIO106_OUT 0x102b2d, BIT0 #define GPIO106_IN 0x102b2d, BIT2 #define GPIO107_PAD PAD_TS1_D5 #define GPIO107_OEN 0x102b2c, BIT1 #define GPIO107_OUT 0x102b2c, BIT0 #define GPIO107_IN 0x102b2c, BIT2 #define GPIO108_PAD PAD_TS1_D6 #define GPIO108_OEN 0x102b2b, BIT1 #define GPIO108_OUT 0x102b2b, BIT0 #define GPIO108_IN 0x102b2b, BIT2 #define GPIO109_PAD PAD_TS1_D7 #define GPIO109_OEN 0x102b2a, BIT1 #define GPIO109_OUT 0x102b2a, BIT0 #define GPIO109_IN 0x102b2a, BIT2 #define GPIO110_PAD PAD_TS1_SYNC #define GPIO110_OEN 0x102b28, BIT1 #define GPIO110_OUT 0x102b28, BIT0 #define GPIO110_IN 0x102b28, BIT2 #define GPIO111_PAD PAD_TS1_VLD #define GPIO111_OEN 0x102b29, BIT1 #define GPIO111_OUT 0x102b29, BIT0 #define GPIO111_IN 0x102b29, BIT2 #define GPIO112_PAD PAD_TS2_CLK #define GPIO112_OEN 0x102b35, BIT1 #define GPIO112_OUT 0x102b35, BIT0 #define GPIO112_IN 0x102b35, BIT2 #define GPIO113_PAD PAD_TS2_D0 #define GPIO113_OEN 0x102b32, BIT1 #define GPIO113_OUT 0x102b32, BIT0 #define GPIO113_IN 0x102b32, BIT2 #define GPIO114_PAD PAD_TS2_SYNC #define GPIO114_OEN 0x102b34, BIT1 #define GPIO114_OUT 0x102b34, BIT0 #define GPIO114_IN 0x102b34, BIT2 #define GPIO115_PAD PAD_TS2_VLD #define GPIO115_OEN 0x102b33, BIT1 #define GPIO115_OUT 0x102b33, BIT0 #define GPIO115_IN 0x102b33, BIT2 #define GPIO_EXT0_MSK 0x10190c, BIT7 #define GPIO_EXT0_POL 0x101914, BIT7 #define GPIO_EXT0_CLR 0x10191c, BIT7 #define GPIO_EXT0_STS 0x10191c, BIT7 #define GPIO_EXT1_MSK 0x10190c, BIT11 #define GPIO_EXT1_POL 0x101914, BIT11 #define GPIO_EXT1_CLR 0x10191c, BIT11 #define GPIO_EXT1_STS 0x10191c, BIT11 #define GPIO_EXT2_MSK 0x10190c, BIT15 #define GPIO_EXT2_POL 0x101914, BIT15 #define GPIO_EXT2_CLR 0x10191c, BIT15 #define GPIO_EXT2_STS 0x10191c, BIT15 #define GPIO_EXT3_MSK 0x10190e, BIT7 #define GPIO_EXT3_POL 0x101916, BIT7 #define GPIO_EXT3_CLR 0x10191e, BIT7 #define GPIO_EXT3_STS 0x10191e, BIT7 #define GPIO_EXT4_MSK 0x10190e, BIT8 #define GPIO_EXT4_POL 0x101916, BIT8 #define GPIO_EXT4_CLR 0x10191e, BIT8 #define GPIO_EXT4_STS 0x10191e, BIT8 #define GPIO_EXT5_MSK 0x10190e, BIT8 #define GPIO_EXT5_POL 0x101916, BIT8 #define GPIO_EXT5_CLR 0x10191e, BIT8 #define GPIO_EXT5_STS 0x10191e, BIT8 #define GPIO_EXT6_MSK 0x10190e, BIT10 #define GPIO_EXT6_POL 0x101916, BIT10 #define GPIO_EXT6_CLR 0x10191e, BIT10 #define GPIO_EXT6_STS 0x10191e, BIT10 #define GPIO_EXT7_MSK 0x10190e, BIT15 #define GPIO_EXT7_POL 0x101916, BIT15 #define GPIO_EXT7_CLR 0x10191e, BIT15 #define GPIO_EXT7_STS 0x10191e, BIT15 例如 PAD_IRIN，PAD_CEC0，PAD_PWM_PM是pin id，在 vendor\\mstar\\kernel\\linaro\\mstar2\\hal\\m7221\\gpio\\mhal_gpio_reg.h 中定义： #define PAD_IRIN 0 #define PAD_CEC0 1 #define PAD_PWM_PM 2 #define PAD_DDCA_CK 3 #define PAD_DDCA_DA 4 #define PAD_GPIO0_PM 5 #define PAD_GPIO1_PM 6 #define PAD_GPIO2_PM 7 #define PAD_USB_CTRL 8 #define PAD_GPIO5_PM 9 #define PAD_GPIO6_PM 10 #define PAD_GPIO7_PM 11 #define PAD_GPIO8_PM 12 #define PAD_GPIO9_PM 13 #define PAD_GPIO10_PM 14 #define PAD_GPIO11_PM 15 #define PAD_GPIO12_PM 16 #define PAD_HOTPLUGA 17 #define PAD_HOTPLUGB 18 #define PAD_HOTPLUGC 19 #define PAD_HOTPLUGA_HDMI20_5V 20 #define PAD_HOTPLUGB_HDMI20_5V 21 #define PAD_HOTPLUGC_HDMI20_5V 22 #define PAD_DDCDA_CK 23 #define PAD_DDCDA_DA 24 #define PAD_DDCDB_CK 25 #define PAD_DDCDB_DA 26 #define PAD_DDCDC_CK 27 #define PAD_DDCDC_DA 28 #define PAD_SAR0 29 #define PAD_SAR1 30 #define PAD_SAR2 31 #define PAD_SAR3 32 #define PAD_SAR4 33 #define PAD_VPLUGIN 34 #define PAD_VID0 35 #define PAD_VID1 36 #define PAD_VID2 37 #define PAD_VID3 38 #define PAD_WOL_INT_OUT 39 #define PAD_I2S_IN_BCK 40 #define PAD_I2S_IN_WS 41 #define PAD_I2S_IN_MCK 42 #define PAD_I2S_IN_SD0 43 #define PAD_I2S_IN_SD1 44 #define PAD_CILINK_DEMOD0_CLK 45 #define PAD_CILINK_DEMOD1_CLK 46 #define PAD_CILINK_INT 47 #define PAD_CILINK_RX0_D0 48 #define PAD_CILINK_RX0_D1 49 #define PAD_CILINK_RX1_D0 50 #define PAD_CILINK_RX1_D1 51 #define PAD_CILINK_RX_CLK 52 #define PAD_CILINK_SPI_CLK 53 #define PAD_CILINK_SPI_CS 54 #define PAD_CILINK_SPI_MISO 55 #define PAD_CILINK_SPI_MOSI 56 #define PAD_CILINK_TX0_D0 57 #define PAD_CILINK_TX0_D1 58 #define PAD_CILINK_TX1_D0 59 #define PAD_CILINK_TX1_D1 60 #define PAD_CILINK_TX_CLK 61 #define PAD_DDCR_CK 62 #define PAD_DDCR_DA 63 #define PAD_GPIO2 64 #define PAD_GPIO3 65 #define PAD_GPIO4 66 #define PAD_GPIO5 67 #define PAD_GPIO9 68 #define PAD_GPIO10 69 #define PAD_GPIO11 70 #define PAD_GPIO12 71 #define PAD_GPIO19 72 #define PAD_GPIO20 73 #define PAD_GPIO25 74 #define PAD_GPIO26 75 #define PAD_GPIO30 76 #define PAD_GPIO31 77 #define PAD_HDMIRX_ARCTX 78 #define PAD_I2S_OUT_BCK 79 #define PAD_I2S_OUT_MCK 80 #define PAD_I2S_OUT_SD 81 #define PAD_I2S_OUT_SD1 82 #define PAD_I2S_OUT_SD2 83 #define PAD_I2S_OUT_WS 84 #define PAD_PWM0 85 #define PAD_PWM1 86 #define PAD_PWM2 87 #define PAD_PWM3 88 #define PAD_SD_CLK 89 #define PAD_SD_CMD 90 #define PAD_SD_D0 91 #define PAD_SD_D1 92 #define PAD_SD_D2 93 #define PAD_SD_D3 94 #define PAD_SPDIF_IN 95 #define PAD_SPDIF_OUT 96 #define PAD_TGPIO0 97 #define PAD_TGPIO1 98 #define PAD_TGPIO2 99 #define PAD_TGPIO3 100 #define PAD_TS1_CLK 101 #define PAD_TS1_D0 102 #define PAD_TS1_D1 103 #define PAD_TS1_D2 104 #define PAD_TS1_D3 105 #define PAD_TS1_D4 106 #define PAD_TS1_D5 107 #define PAD_TS1_D6 108 #define PAD_TS1_D7 109 #define PAD_TS1_SYNC 110 #define PAD_TS1_VLD 111 #define PAD_TS2_CLK 112 #define PAD_TS2_D0 113 #define PAD_TS2_SYNC 114 #define PAD_TS2_VLD 115 #define GPIO_OEN 0 //set o to nake output #define GPIO_ODN 1 #define IN_HIGH 1 //input high #define IN_LOW 0 //input low #define OUT_HIGH 1 //output high #define OUT_LOW 0 //output low 4. pin id 与芯片管脚映射 以GPIO16 为例： #define GPIO16_PAD PAD_GPIO12_PM supernova\\projects\\board\\m7221\\ChipInfo\\MSD96BUXM8.h #define BALL_U3 PAD_GPIO12_PM #define PAD_GPIO12_PM 17 #define GPIO_PAD_17 GPIO16 #ifndef BALL_U3_IS_GPIO #define BALL_U3_IS_GPIO 0 #endif #ifndef PAD_GPIO12_PM_IS_GPIO #define PAD_GPIO12_PM_IS_GPIO BALL_U3_IS_GPIO #endif 其中BALL_U3即为芯片的管脚 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"Android TV  Mstar平台 I2C 配置","date":"2020-05-30T03:38:28.606Z","updated":"2020-05-30T03:38:28.716Z","comments":true,"path":"2020/05/30/Android TV  Mstar平台 I2C 配置/","link":"","permalink":"http://makeafree.github.io/2020/05/30/Android TV  Mstar平台 I2C 配置/","excerpt":"","text":"Android TV : Mstar平台 I2C 配置 芯片的pin 脚可以用作不同的功能，最常用的是作为GPIO，设置为输出模式时，通过高低电平来控制一些外围设置； // 如LED，屏的电源，背光的开关，功放的静音等等。 除了控制设置之外，还需要和外部设置传输数据。 pin 作为GPIO 设置为IN时，是获取外设的高低来判断外设的状态，最常用的一些source 通道的detect，及一些wakeup 功能。 pin 作为SAR 口，获取ADC值； // 如按键板，参照“mstar平台SAR口使用” pin 作为UART / SPI /SD 口； pin 作为I2C 口； 一般来说，大部分有特殊功能的Pin脚其实都可以作为GPIO使用，当将其配置成特殊功能后，就不能同时配为GPIO。所以当发现某个Pin配成GPIO后，却没办法改变它的高低状态时，就要留意一下该Pin脚是否已经被误配为特殊功能了，这时就需要先DISABLE 掉这个特殊功能之后，才能设置成GPIO及其状态设定。每个chip有对应一个init GPIO配置，BD_MST{$Board}.h, drvpadconf.c 1、标准GPIO口配置 总共有4种状态： #define GPIO_NONE 0 // Not GPIO pin (default) #define GPIO_IN 1 // GPI #define GPIO_OUT_LOW 2 // GPO output low #define GPIO_OUT_HIGH 3 // GPO output high2、特殊口配置（1）uart 口配置，特殊功能的pin需要在BD_MST{$Board}.h 中配置，如：BD_MST160D_10ABQM_M7221.h #define DISABLE 0 #define ENABLE 1 #define CONFIG_PADMUX_MODE0 0x00 #define CONFIG_PADMUX_MODE1 0x01 #define CONFIG_PADMUX_MODE2 0x02 #define CONFIG_PADMUX_MODE3 0x03 #define CONFIG_PADMUX_MODE4 0x04 #define CONFIG_PADMUX_MODE5 0x05 #define CONFIG_PADMUX_MODE6 0x06 #define CONFIG_PADMUX_MODE7 0x07 #define CONFIG_PADMUX_MODE8 0x08 #define CONFIG_PADMUX_MODE9 0x09 #define CONFIG_PADMUX_UNKNOWN 0xFF 例如UART3，UART4 配置成了CONFIG_PADMUX_MODE1，其实也是ENABLE。 接着在 vendor\\mstar\\mboot\\MBoot\\sboot\\src*{$Board}*\\drvPadConf.c 文件中设置寄存器值： #ifdef PADS_UART3_MODE #if (PADS_UART3_MODE != CONFIG_PADMUX_UNKNOWN) #define _CONFIG_UART3_MODE ((PADS_UART3_MODE == CONFIG_PADMUX_MODE1) ? BIT2 : \\ (PADS_UART3_MODE == CONFIG_PADMUX_MODE2) ? BIT3 : \\ (PADS_UART3_MODE == CONFIG_PADMUX_MODE3) ? (BIT3 | BIT2) : 0) _RVM1(0x1e05, _CONFIG_UART3_MODE, (BIT3 | BIT2)), #endif #endif #ifdef PADS_UART4_MODE #if (PADS_UART4_MODE != CONFIG_PADMUX_UNKNOWN) #define _CONFIG_UART4_MODE ((PADS_UART4_MODE == CONFIG_PADMUX_MODE1) ? BIT6 : \\ (PADS_UART4_MODE == CONFIG_PADMUX_MODE2) ? BIT7 : \\ (PADS_UART4_MODE == CONFIG_PADMUX_MODE3) ? (BIT7 | BIT6) : 0) _RVM1(0x1e04, _CONFIG_UART4_MODE, (BIT7 | BIT6)), #endif #endif 针对UART3，UART4 设置了寄存器0x1e05 的bit2，0x1e04的bit6 。这样就配置完成了。 （2）I2C 总线功能配置 以I2C2 为例 I2C 的clk，data 脚分别连接在AD16，AC16 两个pin 上面。比较特殊的是这两个pin 都是有复用功能的。所以需要disable掉其特殊功能LED/tcon。 在BD_MST160D_AH_M7221.h中可以关闭LED功能： #define PADS_LED_MODE DISABLE Tcon[11],Tcon[12], 未找到，属于备用的暂不处理 寄存器设置 #ifdef PADS_LED_MODE #if (PADS_LED_MODE != CONFIG_PADMUX_UNKNOWN) #define _CONFIG_LED_MODE ((PADS_LED_MODE == ENABLE) ? BIT4 : 0) _RVM1(0x1eb4, _CONFIG_LED_MODE, BIT4), #if (PADS_LED_MODE == DISABLE) _MEMMAP_PM_, //reg_seperate_wol_led_is_gpio _RVM1(0x0e39, BIT7, BIT7), //reg_led_is_gpio _RVM1(0x0e39, 0, BIT0), _MEMMAP_nonPM_, #endif #endif #endif disable 掉特殊功能之后，开始配置I2C 功能 //SWI2C #define PAD_DDCR_CK_IS_GPIO GPIO_IN //I2C-SCL (EEPROM) #define PAD_DDCR_DA_IS_GPIO GPIO_IN //I2CM-SDA (EEPROM) #define PAD_TGPIO0_IS_GPIO GPIO_IN //TUNER_SCL #define PAD_TGPIO1_IS_GPIO GPIO_IN //TUNER_SDA #define PAD_GPIO19_IS_GPIO GPIO_IN //I2C2-SCL #define PAD_GPIO20_IS_GPIO GPIO_IN //I2C2-SDA* 将GPIO19，GPIO20 配置成了GPIO_IN，接着进行寄存器配置。如下： #if(PAD_GPIO19_IS_GPIO != GPIO_NONE) #define PAD_GPIO19_OEN (PAD_GPIO19_IS_GPIO == GPIO_IN ? BIT1: 0) #define PAD_GPIO19_OUT (PAD_GPIO19_IS_GPIO == GPIO_OUT_HIGH ? BIT0: 0) _RVM1(0x2b08, PAD_GPIO19_OUT, BIT0), _RVM1(0x2b08, PAD_GPIO19_OEN, BIT1), //reg_tconconfig11 _RVM1(0x1ea1, 0, BIT3), //reg[101ea1]#3 = 0b //reg_agc_dbg _RVM1(0x1e9e, 0, BIT7), //reg[101e9e]#7 = 0b //reg_led_mode _RVM1(0x1eb4, 0, BIT4), //reg[101eb4]#4 = 0b //reg_seconduartmode _RVM1(0x1e05, 0, BIT1 | BIT0), //reg[101e05]#1 ~ #0 = 00b //reg_od2nduart _RVM1(0x1ea9, 0, BIT1 | BIT0), //reg[101ea9]#1 ~ #0 = 00b //reg_miic_mode0 _RVM1(0x1edc, 0, BIT0), //reg[101edc]#0 = 0b #endif #if(PAD_GPIO20_IS_GPIO != GPIO_NONE) #define PAD_GPIO20_OEN (PAD_GPIO20_IS_GPIO == GPIO_IN ? BIT1: 0) #define PAD_GPIO20_OUT (PAD_GPIO20_IS_GPIO == GPIO_OUT_HIGH ? BIT0: 0) _RVM1(0x2b09, PAD_GPIO20_OUT, BIT0), _RVM1(0x2b09, PAD_GPIO20_OEN, BIT1), //reg_tconconfig12 _RVM1(0x1ea1, 0, BIT4), //reg[101ea1]#4 = 0b //reg_agc_dbg _RVM1(0x1e9e, 0, BIT7), //reg[101e9e]#7 = 0b //reg_led_mode _RVM1(0x1eb4, 0, BIT4), //reg[101eb4]#4 = 0b //reg_seconduartmode _RVM1(0x1e05, 0, BIT1 | BIT0), //reg[101e05]#1 ~ #0 = 00b //reg_od2nduart _RVM1(0x1ea9, 0, BIT1 | BIT0), //reg[101ea9]#1 ~ #0 = 00b //reg_vx1gpi_mode _RVM1(0x1e4a, 0, BIT1 | BIT0), //reg[101e4a]#1 ~ #0 = 00b //reg_miic_mode0 _RVM1(0x1edc, 0, BIT0), //reg[101edc]#0 = 0b //reg_extint5 _RVM1(0x1ea5, 0, BIT5), //reg[101ea5]#5 = 0b #endif 其实配置成GPIO_IN 容易和 标准GPIO IN 模式产生误解。应该区别一下定义成IIC_MODE等其他宏，然后drvpadconf.c 文件中，设置寄存器即可。 寄存器值的设置才是pin 的功能设置的本质，这样就完成mboot里面pin的功能定义。 3、使用实例 - 移植TCA9539 tca959 作为一款纯IIC控制的mcu，上电后即可通过主控IC的 I2C 来控制mcu 的管脚，设置这些pin的input / output 模式，以及获取output的高低，另外也可以获取input的状态。通常主控IC的IO口不够用时用来扩展IO口。 (1)TCA9539 I2C地址确定 查看TCA9539 的datasheet 文档，地址部分，总共有7位，其中Slave address 的bit 位固定，另外最后两个bits 位根据原理图中地址pin 的高低来判断 查看原理图发现，tca9539 的I2C地址脚IIC_SEL0，IIC_SEL1 接的是下拉电阻，两个PIN都是低电平，故地址应该取0x74. 结合原理图和datasheet 得到一个7bit 的I2C地址后，需要左移(x2), 末尾补零生成一个8bit 的地址（包含读写位）给软件使用，计算后该地址为 0xE8. (2)TCA9539 I2C地址配置 找到对应板型的board.h 文件，配置tca9539 IIC 信息。包含在那一组IIC及设备的IIC 地址。其中TCA9539_I2C_ID 只是一个枚举值方便应用调用。 (3)管脚功能配置 功能配置主要是配置对应pin的输入，输出模式及输出模式的高低状态 根据datasheet 的说明，寄存器0x06 , 0x07 分别配置port 0~ 7 ，port 10~17对应bit位为1 则为输入 为0 则为输出。 而寄存器0x04, 0x05 分别是设置port 0 ~ 7，port 10 ~ 17 的极性。 例如：设置P3，P4，P5，P7，P10，P11 需要设置为output，其它为input模式： #define TCA9539_MASK_P0 (1 &lt;&lt; 0) #define TCA9539_MASK_P1 (1 &lt;&lt; 1) #define TCA9539_MASK_P2 (1 &lt;&lt; 2) #define TCA9539_MASK_P3 (1 &lt;&lt; 3) #define TCA9539_MASK_P4 (1 &lt;&lt; 4) #define TCA9539_MASK_P5 (1 &lt;&lt; 5) #define TCA9539_MASK_P6 (1 &lt;&lt; 6) #define TCA9539_MASK_P7 (1 &lt;&lt; 7) // P3,P4,P5,P7 set to output 0x47 static MAPI_U8 uTca9539_Ports_L_Mode = 0xFF &amp; \\ (~(TCA9539_MASK_P3)) &amp; \\ (~(TCA9539_MASK_P4)) &amp; \\ (~(TCA9539_MASK_P5)) &amp; \\ (~(TCA9539_MASK_P7)); // P10,P11 set to output 0xFC static MAPI_U8 uTca9539_Ports_H_Mode = (0xFF &amp; (~(TCA9539_MASK_P0)) &amp; (~(TCA9539_MASK_P1))); 定义寄存器0x06 需要初始化的值0x47 (0100 0111), 二进制从右到左 bit0~bit7 对应port0 ~ port7；寄存器 0x07，需要初始化的值0xFC (1111 1100) ，二进制从右到左bit0 ~ bit7 对应port10 ~ port17. MAPI_U8 uCfgLowPorts = 0x06; MAPI_U8 uCfgHighPorts = 0x07; iptr = mapi_i2c::GetI2C_Dev(TCA9539_I2C_ID); if(iptr == NULL) { printf(\"[%s][%d] Invalid I2c mcu addr .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // config the port mode &lt;input or output&gt; if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uCfgLowPorts,1,&amp;uTca9539_Ports_L_Mode)) { printf(\"[%s][%d] wirte the port 0~7 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uCfgHighPorts,1,&amp;uTca9539_Ports_H_Mode)) { printf(\"[%s][%d] wirte the port 10~17 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } 这样就完成input ， output 模式的配置。 (4)读取输出管脚状态 通过datasheet得到，寄存器0x00,0x01 是用来获取port 的状态： MAPI_U8 uLowRegAddr = 0x00; MAPI_U8 uHighRegAddr = 0x01; MAPI_U8 uOldData = 0x00; MAPI_U8 uData = 0x00; MAPI_U8 uMask = 0x00; MAPI_U8 uRRegAddr = (port &gt; TCA9539_P7) ? uHighRegAddr : uLowRegAddr; iptr = mapi_i2c::GetI2C_Dev(TCA9539_I2C_ID); if(iptr == NULL) { printf(\"[%s][%d] Invalid I2c mcu addr .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // 获取port 口该组的所有状态 if(MAPI_FALSE == iptr-&gt;ReadBytes(1, &amp;uRRegAddr, 1, &amp;uOldData)) { printf(\"[%s][%d] get the port status failed .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // 计算返回对应port 口的状态 return (uData &gt;&gt; (port % 10) | 0x01)； (5)设置输出管脚状态 通过datasheet可知，输出管脚的状态，通过寄存器0x2,0x03 来设置： MAPI_BOOL device_mcu_tca9539::Set_port_Output(MAPI_U8 port, MAPI_BOOL bOutState) { mapi_i2c *iptr = NULL; // for output status MAPI_U8 uLowRegAddr = 0x00; MAPI_U8 uHighRegAddr = 0x01; MAPI_U8 uLowWReg = 0x02; MAPI_U8 uHighWReg = 0x03; MAPI_U8 uOldData = 0x00; MAPI_U8 uData = 0x00; MAPI_U8 uMask = 0x00; MAPI_U8 uRRegAddr = (port &gt; TCA9539_P7) ? uHighRegAddr : uLowRegAddr; MAPI_U8 uWRegAddr = (port &gt; TCA9539_P7) ? uHighWReg : uLowWReg; iptr = mapi_i2c::GetI2C_Dev(TCA9539_I2C_ID); if(iptr == NULL) { printf(\"[%s][%d] Invalid I2c mcu addr .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // 通过寄存器0x00（port0 ~ port7）/0x01（port10 ~ port17）读取当前port口的状态 if(MAPI_FALSE == iptr-&gt;ReadBytes(1, &amp;uRRegAddr, 1, &amp;uOldData)) { printf(\"[%s][%d] get the port status failed .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // 计算，并设置port 的新状态，其它port 状态不变 uMask = 1 &lt;&lt; (port % 10); // set the new status if(bOutState){ uData = (uMask | uOldData); // set H } else { uData = (~uMask) &amp; uOldData; // set L } // 对寄存器0x02（port0 ~ port7）/0x03（port10 ~ port17）写输出的高低状态 if(MAPI_FALSE == iptr-&gt;WriteBytes(1, &amp;uWRegAddr, 1, &amp;uData)) { printf(\"[%s][%d] set the new status failed .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } printf(\"[%s][%d] set the P%02d to %d.\\n\",__FUNCTION__,__LINE__,port,bOutState); return MAPI_TRUE; } 完整驱动代码 ： device_mcu_tca9539.h: #ifndef __DEVIDE_MCU_TCA9539_H__ #define __DEVIDE_MCU_TCA9539_H__ /*@ &lt;Include&gt; @*/ #include \"mapi_mcu.h\" #include \"MsTypes.h\" #include \"MTypes.h\" /*@ &lt;/Include&gt; @*/ #define PORT_INPUT (1) #define PORT_OUTPUT (0) #define OUTPUT_H (1) #define OUTPUT_L (0) #define TCA9539_P0 (0) #define TCA9539_P1 (1) #define TCA9539_P2 (2) #define TCA9539_P3 (3) #define TCA9539_P4 (4) #define TCA9539_P5 (5) #define TCA9539_P6 (6) #define TCA9539_P7 (7) #define TCA9539_P10 (10) #define TCA9539_P11 (11) #define TCA9539_P12 (12) #define TCA9539_P13 (13) #define TCA9539_P14 (14) #define TCA9539_P15 (16) #define TCA9539_P16 (15) #define TCA9539_P17 (17) #define TCA9539_MASK_P0 (1 &lt;&lt; 0) #define TCA9539_MASK_P1 (1 &lt;&lt; 1) #define TCA9539_MASK_P2 (1 &lt;&lt; 2) #define TCA9539_MASK_P3 (1 &lt;&lt; 3) #define TCA9539_MASK_P4 (1 &lt;&lt; 4) #define TCA9539_MASK_P5 (1 &lt;&lt; 5) #define TCA9539_MASK_P6 (1 &lt;&lt; 6) #define TCA9539_MASK_P7 (1 &lt;&lt; 7) class device_mcu_tca9539 : public mapi_mcu { public: DLL_PUBLIC device_mcu_tca9539(void); DLL_PUBLIC ~device_mcu_tca9539(void); DLL_PUBLIC MAPI_BOOL Init(void); DLL_PUBLIC MAPI_BOOL Finalize(void); DLL_PUBLIC MAPI_BOOL Reset(void); DLL_PUBLIC MAPI_BOOL Set_port_mode(MAPI_U8 port, MAPI_BOOL bInput); DLL_PUBLIC MAPI_BOOL Get_port_mode(MAPI_U8 port, MAPI_U8 *uMode); DLL_PUBLIC MAPI_BOOL Set_port_Output(MAPI_U8 port, MAPI_BOOL bOutState); DLL_PUBLIC MAPI_BOOL Get_port_State(MAPI_U8 port, MAPI_BOOL *bMode, MAPI_BOOL *bState); DLL_PUBLIC MAPI_BOOL Tca9539Setup(void); }; #endif // __DEVIDE_LED_DEFAULT_H__ device_mcu_tca9539.cpp: #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; #include &lt;cstring&gt; #include \"MsCommon.h\" #include \"MsOS.h\" #include &lt;dirent.h&gt; // #include \"mapi_gpio.h\" #include \"mapi_i2c.h\" #include \"mapi_i2c_devTable.h\" #include \"mapi_gpio_devTable.h\" #include \"device_mcu_tca9539.h\" #include \"MSrv_Control_common.h\" // P3,P4,P5,P7 set to output 0x47 static MAPI_U8 uTca9539_Ports_L_Mode = 0xFF &amp; \\ (~(TCA9539_MASK_P3)) &amp; \\ (~(TCA9539_MASK_P4)) &amp; \\ (~(TCA9539_MASK_P5)) &amp; \\ (~(TCA9539_MASK_P7)); // P10,P11 set to output 0xFC static MAPI_U8 uTca9539_Ports_H_Mode = (0xFF &amp; (~(TCA9539_MASK_P0)) &amp; (~(TCA9539_MASK_P1))); device_mcu_tca9539::device_mcu_tca9539(void) { } device_mcu_tca9539::~device_mcu_tca9539(void) { } MAPI_BOOL device_mcu_tca9539::Init(void) { return Reset(); } MAPI_BOOL device_mcu_tca9539::Finalize(void) { BOOL bRet = FALSE; printf(\"Finalize TCA9539\\n\"); bRet = MSrv_Control_common::SetGpioDeviceStatus(MCU_RESET,FALSE); return (bRet) ? MAPI_TRUE : MAPI_FALSE; } MAPI_BOOL device_mcu_tca9539::Reset(void) { BOOL bRet1 = FALSE; BOOL bRet2 = FALSE; printf(\"Reset TCA9539\\n\"); bRet1 = MSrv_Control_common::SetGpioDeviceStatus(MCU_RESET,FALSE); usleep(100*1000); // 100ms bRet2 = MSrv_Control_common::SetGpioDeviceStatus(MCU_RESET,TRUE); Tca9539Setup(); return (bRet1 &amp;&amp; bRet2) ? MAPI_TRUE : MAPI_FALSE; } MAPI_BOOL device_mcu_tca9539::doHandleOps(void) { MAPI_BOOL bMode = FALSE; MAPI_BOOL bPlugState = TRUE; // plug out: ops H ; plug in : ops L MAPI_BOOL bState = TRUE; // ops status. H: off; L: on // OPS Det Get_port_State(TCA9539_P6, &amp;bMode, &amp;bPlugState); // OPS power Get_port_State(TCA9539_P17, &amp;bMode, &amp;bState); if((!bPlugState)&amp;&amp;(bState)){ // // set ops on // uData = 0x7F; // P3 = H ,P7 = L // if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uLowRegAddr,1,&amp;uData)) // { // printf(\"[%s][%d] wirte the port 10~17 failed.\\n\",__FUNCTION__,__LINE__); // return MAPI_FALSE; // } // usleep(100*1000); // uData = 0xFF; // P3 = H ,P7 = H // if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uLowRegAddr,1,&amp;uData)) // { // printf(\"[%s][%d] wirte the port 10~17 failed.\\n\",__FUNCTION__,__LINE__); // return MAPI_FALSE; // } Set_port_Output(TCA9539_P7,MAPI_FALSE); // to L usleep(100*1000); Set_port_Output(TCA9539_P7,MAPI_TRUE); // to H printf(\"[%s][%d] start the ops .\\n\",__FUNCTION__,__LINE__); return TRUE; } return FALSE; } MAPI_BOOL device_mcu_tca9539::Tca9539Setup(void) { mapi_i2c *iptr = NULL; MAPI_U8 uCfgLowPorts = 0x06; MAPI_U8 uCfgHighPorts = 0x07; // for output status MAPI_U8 uLowRegAddr = 0x02; MAPI_U8 uHighRegAddr = 0x03; MAPI_U8 uData = 0x00; printf(\"[%s][%d] Enter .\\n\",__FUNCTION__,__LINE__); iptr = mapi_i2c::GetI2C_Dev(TCA9539_I2C_ID); if(iptr == NULL) { printf(\"[%s][%d] Invalid I2c mcu addr .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // config the port mode &lt;input or output&gt; if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uCfgLowPorts,1,&amp;uTca9539_Ports_L_Mode)) { printf(\"[%s][%d] wirte the port 0~7 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uCfgHighPorts,1,&amp;uTca9539_Ports_H_Mode)) { printf(\"[%s][%d] wirte the port 10~17 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // config: set port(output) status uData = 0xF7; // P3 = L , other bit was seted to H if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uLowRegAddr,1,&amp;uData)) { printf(\"[%s][%d] wirte the port 0~7 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // set touch power uData = 0xFC; // P10, P11 = L , other bit was seted to H if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uHighRegAddr,1,&amp;uData)) { printf(\"[%s][%d] wirte the port 0~7 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } doHandleOps(); #if 0 // set ops on uData = 0x7F; // P3 = H ,P7 = L if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uLowRegAddr,1,&amp;uData)) { printf(\"[%s][%d] wirte the port 10~17 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } usleep(100*1000); uData = 0xFF; // P3 = H ,P7 = H if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uLowRegAddr,1,&amp;uData)) { printf(\"[%s][%d] wirte the port 10~17 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } #endif #if 0 // config the S_USB_SEL // uData = 0xFE; // P10 = L android source uData = 0xFF; // P10 = H OPS source if(MAPI_FALSE == iptr-&gt;WriteBytes(1,&amp;uHighRegAddr,1,&amp;uData)) { printf(\"[%s][%d] wirte the port 10~17 failed.\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } #endif printf(\"[%s][%d] setup success.\\n\",__FUNCTION__,__LINE__); return MAPI_TRUE; } // bInput: TRUE --&gt; input , FALSE --&gt; output MAPI_BOOL device_mcu_tca9539::Set_port_mode(MAPI_U8 port, MAPI_BOOL bInput) { printf(\"[%s][%d] Enter .\\n\",__FUNCTION__,__LINE__); return MAPI_TRUE; } // uMode: 1 --&gt; input, 0 --&gt; output MAPI_BOOL device_mcu_tca9539::Get_port_mode(MAPI_U8 port, MAPI_U8 *uMode) { printf(\"[%s][%d] Enter .\\n\",__FUNCTION__,__LINE__); return MAPI_TRUE; } MAPI_BOOL device_mcu_tca9539::Set_port_Output(MAPI_U8 port, MAPI_BOOL bOutState) { mapi_i2c *iptr = NULL; // for output status MAPI_U8 uLowRegAddr = 0x00; MAPI_U8 uHighRegAddr = 0x01; MAPI_U8 uLowWReg = 0x02; MAPI_U8 uHighWReg = 0x03; MAPI_U8 uOldData = 0x00; MAPI_U8 uData = 0x00; MAPI_U8 uMask = 0x00; MAPI_U8 uRRegAddr = (port &gt; TCA9539_P7) ? uHighRegAddr : uLowRegAddr; MAPI_U8 uWRegAddr = (port &gt; TCA9539_P7) ? uHighWReg : uLowWReg; iptr = mapi_i2c::GetI2C_Dev(TCA9539_I2C_ID); if(iptr == NULL) { printf(\"[%s][%d] Invalid I2c mcu addr .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // get the old status if(MAPI_FALSE == iptr-&gt;ReadBytes(1, &amp;uRRegAddr, 1, &amp;uOldData)) { printf(\"[%s][%d] get the port status failed .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } uMask = 1 &lt;&lt; (port % 10); // set the new status if(bOutState){ uData = (uMask | uOldData); // set H } else { uData = (~uMask) &amp; uOldData; // set L } if(MAPI_FALSE == iptr-&gt;WriteBytes(1, &amp;uWRegAddr, 1, &amp;uData)) { printf(\"[%s][%d] set the new status failed .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } printf(\"[%s][%d] set the P%02d to %d.\\n\",__FUNCTION__,__LINE__,port,bOutState); return MAPI_TRUE; } MAPI_BOOL device_mcu_tca9539::Get_port_State(MAPI_U8 port, MAPI_BOOL *bMode, MAPI_BOOL *bState) { mapi_i2c *iptr = NULL; // used for port status MAPI_U8 uInLowRegAddr = 0x00; MAPI_U8 uInHighRegAddr = 0x01; MAPI_U8 uRegAddr = (port &gt; TCA9539_P7) ? uInHighRegAddr : uInLowRegAddr; // for port mode MAPI_U8 uLowPorts = 0x06; MAPI_U8 uHighPorts = 0x07; MAPI_U8 uModeRegAddr = (port &gt; TCA9539_P7) ? uHighPorts : uLowPorts; MAPI_U8 uData = 0x00; MAPI_U8 uMode = 0x00; if(NULL == bMode || NULL == bState || (port &gt; TCA9539_P17 || port &lt; TCA9539_P0)) { printf(\"[%s][%d] param error .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } iptr = mapi_i2c::GetI2C_Dev(TCA9539_I2C_ID); if(iptr == NULL) { printf(\"[%s][%d] Invalid I2c mcu addr .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } // get the port mode &lt;input/outputO&gt; if(MAPI_FALSE == iptr-&gt;ReadBytes(1, &amp;uModeRegAddr, 1, &amp;uData)) { printf(\"[%s][%d] get the old status failed .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } uMode = (uData &gt;&gt; (port % 10)) &amp; 0x01; *bMode = uMode; uData = 0x00; if(MAPI_FALSE == iptr-&gt;ReadBytes(1, &amp;uRegAddr, 1, &amp;uData)) { printf(\"[%s][%d] get the port status failed .\\n\",__FUNCTION__,__LINE__); return MAPI_FALSE; } printf(\"[%s][%d] uRegAddr [0x%02x] , uData [0x%02x] \\n\", __FUNCTION__,__LINE__, uRegAddr, uData); *bState = (uData &gt;&gt; (port % 10) &amp; 0x01); printf(\"[%s][%d] P%02d mode &lt;%s&gt; , state [%d] \\n\", __FUNCTION__,__LINE__, port, (bMode ? \"Input\":\"Output\"), *bState); return MAPI_TRUE; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"keywords":[]},{"title":"【程序人生】程序员接私活常用平台汇总","slug":"【程序人生】程序员接私活常用平台汇总","date":"2020-03-29T16:00:00.000Z","updated":"2020-03-29T17:14:10.409Z","comments":true,"path":"2020/03/30/【程序人生】程序员接私活常用平台汇总/","link":"","permalink":"http://makeafree.github.io/2020/03/30/【程序人生】程序员接私活常用平台汇总/","excerpt":"","text":"目录 前言 程序员客栈 码市 猪八戒网 开源众包 智城外包网 实现网 猿急送 人人开发 开发邦 电鸭社区 快码 英选 Upwork Freelancer Dribbble Remoteok Toptal AngelList Topcoder 关于程序员接私活，社会各界说法不一。按照作者的观点来说如果你确实急用钱，价格又合适，那就去做。如果不怎么缺钱，那就接私活之前要好好考虑。私活的钱不好挣是一个方面，更重要的是如果你把做私活的时间花在提升自己上，产生的价值就要大得多。等你提升了自己，提升了固定薪水，远比拿的这点私活的钱划算。千万不要“捡了芝麻丢了西瓜”。 如果你主业上遇到了瓶颈，平时的时间比较充分，想有一些额外的收入，同时为了保持技术的熟练度，这种情况下，是可以考虑接一些私活的。对于那种投入时间巨大，回报很可怜的项目，千万不要接。 下面介绍一些常用的平台可以接私活。 程序员客栈 程序员客栈中国非常领先的自由工作平台，为中高端程序员、产品经理和设计师等等互联网相关人员提供稳定的线上工作机会，包括自由工作、远程工作和兼职工作，还支持按需雇佣，工作模式非常多，感兴趣的推荐大家尝试一下。虽然名称叫程序员客栈，但是除了程序员，像产品经理，设计师等等互联网相关人员，都能在上面找到适合自己的项目。感兴趣的可以体验一下。 程序员客栈官网：https://www.proginn.com/ 码市 码市是 Coding 推出的互联网软件外包服务平台,意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者,完成项目开发工作。 码市官方网站：https://codemart.com/ 猪八戒网 猪八戒网创建于2006年，是服务中小微企业的人才共享平台。开创式地为人才与雇主搭建起双边市场，通过线上线下资源整合与大数据服务，实现人才与雇主精准无缝对接。找兼职的地方，主要是入门级项目，不适合专业程序员，只适合新手。 猪八戒官网：https://luoyang.zbj.com/ 开源众包 开源众包–专业的软件众包平台,350万+ 优质开发者为您提供网站、APP、微信/小程序、企业应用等软件开发服务,有效降低企业 IT 软件开发成本、解决技术资源不足等问题。 开源中国的众包平台，主要是以众包为主。 开源众包官网：https://zb.oschina.net/ 智城外包网 智城外包网，聚合全国软件团队资源，官方认证，1小时响应，零交易佣金，托管安全保障。十年口碑运营，万家靠谱团队。免费比价，免费一站式外包项目管理工具。平台汇集软件咨询专家，软件技术专家，软件开发专家，软件开发公司，软件外包公司，软件外派公司。在线竞标模式，让IT外包项目和短期IT招聘、人力派遣需求可以获得高性价比的候选。海量资源池包括：网站设计、网站开发、手机应用开发、移动应用开发、安卓应用开发、苹果应用开发、微信应用开发、Java技术、C＃技术、Web前端开发、IT人力外包、IT人力外派、IT人力短期招聘、技术合伙人、通用软件开发，SaaS软件实施，软件运维等服务门类。 网官方网站：http://www.taskcity.com/ 实现网 北京实现与爱科技有限公司是一个互联网工程师兼职平台。解决创业公司招人难、成本高的问题。 创业公司通过实现网可以快速预约知名互联网企业的工程师、设计师到自己的团队工作。上午预约工程师，最快晚上即可到班兼职。 互联网工程师可以在实现网注册成为技术顾问，利用业余时间助力创业公司，并且获得以时薪为单位的报酬。 目前已有9000+工程师或设计师可在线预约和支付，支付后工程师会到团队里坐班沟通，快速推进创业者的产品开发进度。 实现网为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求。已服务2000多家企业，包括好未来、方正、人人贷、秒拍等知名企业。 官方网站：https://shixian.com/ 猿急送 猿急送，一个高级技术共享平台，这里汇聚知名互联网公司的技术、设计、产品大牛，通过实际坐班、远程等方式，一对一为创业公司解决问题，提高创业效率。 猿急送为您提供兼职程序员，兼职工程师信息，猿急送是一个高级技术共享平台，是优质的程序员兼职网站，这里汇聚BAT等知名互联网公司的技术开发、产品、设计大牛，通过实际坐班等方式，一对一为创业公司解决程序员、工程师等开发、产品设计人力问题。 官方网站：https://www.yuanjisong.com/ 人人开发 人人开发基于可视化快速开发平台 - 捷得（Joget）/捷得云（Joget Cloud）（PaaS），集众多开发者资源，为企业提供企业管理软件服务。应用市场提供应用产品、插件的在线试用和销售，服务市场以威客众包模式提供管理软件定制开发服务，各类企业级应用开发服务，例如：协同OA产品，ERP，CRM，人事管理，项目管理，资产管理，设备管理等。 官方网站：http://rrkf.com/ 开发邦 公司位于北京中关村科技园区核心区海淀园，成立于2010年，专注于为客户提供互联网软件技术开发与咨询服务，致力于利用互联网软件技术为客户提高效率、降低成本、提升效能、优化管理。 团队核心成员均具有十年以上软件互联网技术开发经验，毕业于工科名校。至今，已成功执行近百个项目，涵盖管理软件、互联网系统、移动APP、前端互动开发等。 先后为华为公司、商汤科技、工信部中国软件评测中心、神州数码、深鉴科技、中软集团、中国万网、中石油吐哈气举中心、华北电力大学、中科院科技政策与管理研究所、浪潮集团、ADI、世界五百强伊顿中国、北京外国语大学、51talk、勤邦生物、安龙基因等知名企业及机构提供过互联网软件技术开发与技术咨询服务。 开发邦致力于成为企业业务互联网软件服务与咨询的定制方案提供商。 官方网站：https://www.kaifabang.com/ 电鸭社区 电鸭社区旨在帮助更多人走上「只工作，不上班」的自由工作之路，我们是一个「分布式组织」，通过分享及行动带来积极的影响，相信点滴的力量能改变潮水的方向。 官方网站：https://eleduck.com/ 快码 深圳快码科技成立于2014年11月，是一家创新型的互联网公司，致力于通过创新的开发方式，为软件技术开发行业带来改变，提供更快速、更高性价比的软件定制服务。 “快码”的意思是“快速编写代码”。公司采用“专属项目经理 + 自有开发团队 + 平台程序员”的创新开发方式，严格按照互联网公司的标准来管理开发团队，确保每个项目都有充足的人员投入，确保项目的进度和开发质量。2015年，我们和全球最大的手游、APP云测试平台Testin达成战略合作协议，并获得Testin数百万的战略投资。 目前平台已注册的开发者达到3万多人，涵盖各种开发语言与类型，可以提供开发的项目有iOS APP、安卓APP、微信公众号、PC网站、手机网站、微信小程序、桌面软件、智能硬件APP等。上线以来，我们已经完成了数千项目&amp;任务的开发。 创业灵感来自于快码团队的从业经验。在近十年的互联网技术经历中，对由于创业公司、外包公司人员不稳定，招聘困难、人手有限等问题而导致现有团队开发任务过重，开发进度缓慢等问题有着切身之痛，将在P2P旅游行业2年多的共享经济经验，和自身最熟悉的“软件开发”结合，创立了“快码”。 快码将立足于代码开发，深耕行业，面向未来，通过持续的产品创新，为广大项目方、开发者提供专业的服务，为软件技术开发行业带来改变。 快码是一个创新的软件开发平台。项目方可以更省钱、高效地完成项目的开发；开发者可以充分利用闲置时间，实现更高的商业价值！ 官方网站：https://www.kuai.ma/ 英选 英选，可信赖的软件外包服务。用优秀的人，做漂亮的产品，写干净的代码。平台以定制开发外包服务为主，也是外包项目平台。 官方网站：https://www.yingxuan.io/ Upwork Upwork 是全球最大的、最优秀的、最规范的综合类人力外包服务平台，由著名的 Elance 和 oDesk 合并。这里聚集 900 万来自全球各地的自由工作者，你肯定可以在找到适合你的职位。 官方网站：https://www.upwork.com/ Freelancer Freelancer 的工作类型覆盖了很多不同的领域，由程序开发到市场营销、广告、会计、法务等一系列的可以远程的工作。 官方网站：https://www.freelance.com/ DribbbleDribbble 不只是全球最受欢迎的设计师社区，同样是设计师寻找远程工作的好出处。自从被 Tiny 收购后，Dribbble 的招聘属性正在慢慢增强，试着持续 PO 出自己的好作品，等待你的伯乐，同样你可以关注 Jobs 页面，给心仪的 Team 提交简历。 官方网站：https://dribbble.com/jobs Remoteok Remoteok 不仅提供最初的兼职类远程工作，还有全职类，签署合同类和实习类的工作。网站创始人 Pieter Levels 本身就是一名数字游民，他同样是 Nomadlist 的创始人。 官方网站：https://remoteok.io/ Toptal Toptal 是一个高端一些的自由职业者平台，适合比较有经验和工作尽力的远程工作者。它将企业与全球的软件工程师，设计师和业务顾问联系起来。 官方网站：https://www.toptal.com/ AngelList AngelList 主要是服务于初创公司和天使投资人的平台，这里还有初创公司提供的远程工作的机会，如果对远程加入初创公司感兴趣的，可以尝试一下。 官方网站：https://angel.co/remote Topcoder Topcoder 通过算法比赛吸引世界顶级的程序员，他会将一下大型项目分割成很多小模块，通过竞赛的模式交给用户来做，优胜者可以拿到制定模块的奖金。 官方网站：https://www.topcoder.com/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"程序人生","slug":"程序人生","permalink":"http://makeafree.github.io/categories/程序人生/"}],"tags":[{"name":"常识知识","slug":"常识知识","permalink":"http://makeafree.github.io/tags/常识知识/"}],"keywords":[{"name":"程序人生","slug":"程序人生","permalink":"http://makeafree.github.io/categories/程序人生/"}]},{"title":"修改Jupyter Notebook默认打开路径","slug":"修改Jupyter Notebook默认打开路径","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-08T09:13:04.860Z","comments":true,"path":"2019/12/08/修改Jupyter Notebook默认打开路径/","link":"","permalink":"http://makeafree.github.io/2019/12/08/修改Jupyter Notebook默认打开路径/","excerpt":"","text":"修改Jupyter Notebook默认打开路径当前jupyter notebook 的启动工作路径就是在 c:\\Users\\用户名，为了使每次都在一个指定的工作路径下打开，可按如下设置： 1、打开命令行界面,使用win+R然后输入cmd回车后，打开命令行界面， 然后输入jupyter notebook –gernerate-config，然后回车，如下图所示： 2、生成之后在C:\\Users\\计算机名字.jupyter\\jupyter_notebook_config.py,使用编辑器(notepad++或者sublime text)打开,找到#c.NotebookApp.notebook_dir = ‘’在引号中添加你定义的路径，需要注意的是要用‘\\’或者‘/’，最后单引号前面加上r(后面学习Python过程中会学到r的意义)，自定义之后，将最前面的#号去掉，设置好后如下图所示： 3、保存文档后，再次在命令行输入jupyter notebook指令即可在指定的文件夹下启动。 注意：启动方式有两种：第一：命令行输入jupyter notebook第二：window应用程序中找到anaconda文件夹下的jupyter notebook.exe打开 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"python","slug":"python","permalink":"http://makeafree.github.io/categories/python/"}],"tags":[{"name":"python文件","slug":"python文件","permalink":"http://makeafree.github.io/tags/python文件/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://makeafree.github.io/categories/python/"}]},{"title":"【Linux网络编程】网络基础知识","slug":"【Linux网络编程】网络基础知识","date":"2019-11-30T16:00:00.000Z","updated":"2019-12-08T09:13:46.591Z","comments":true,"path":"2019/12/01/【Linux网络编程】网络基础知识/","link":"","permalink":"http://makeafree.github.io/2019/12/01/【Linux网络编程】网络基础知识/","excerpt":"","text":"##【Linux网络编程】网络基础知识 00. 目录文章目录00.目录01. 网络基础知识02. 附录 01. 网络基础知识1）什么是链接？ 链接是指两个设备之间的连接。它包括用于一个设备能够与另一个设备通信的电缆类型和协议。 2）OSI 参考模型的层次是什么？ 有 7 个 OSI 层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。 3）什么是骨干网？ 骨干网络是集中的基础设施，旨在将不同的路由和数据分发到各种网络。它还处理带宽管理和各种通道。 4）什么是 LAN？ LAN 是局域网的缩写。它是指计算机与位于小物理位置的其他网络设备之间的连接。 5）什么是节点？ 节点是指连接发生的点。它可以是作为网络一部分的计算机或设备。为了形成网络连接，需要两个或更多个节点。 6）什么是路由器？ 路由器可以连接两个或更多网段。这些是在其路由表中存储信息的智能网络设备，例如路径，跳数等。有了这个信息，他们就可以确定数据传输的最佳路径。路由器在 OSI 网络层运行。 7）什么是点对点链接？ 它是指网络上两台计算机之间的直接连接。除了将电缆连接到两台计算机的 NIC卡之外，点对点连接不需要任何其他网络设备。 8）什么是匿名 FTP？ 匿名 FTP 是授予用户访问公共服务器中的文件的一种方式。允许访问这些服务器中的数据的用户不需要识别自己，而是以匿名访客身份登录。 9）什么是子网掩码？ 子网掩码与 IP 地址组合，以识别两个部分：扩展网络地址和主机地址。像 IP 地址一样，子网掩码由 32 位组成。 10）UTP 电缆允许的最大长度是多少？ UTP 电缆的单段具有 90 到 100 米的允许长度。这种限制可以通过使用中继器和开关来克服 11）什么是数据封装？ 数据封装是在通过网络传输信息之前将信息分解成更小的可管理块的过程。在这个过程中，源和目标地址与奇偶校验一起附加到标题中。 12）描述网络拓扑 网络拓扑是指计算机网络的布局。它显示了设备和电缆的物理布局，以及它们如何连接到彼此。 14）简要描述 NAT。 NAT 是网络地址转换。这是一种协议，为公共网络上的多台计算机提供一种方式来共享到 Internet 的单一连接。 15）OSI 参考模型下网络层的工作是什么？ 网络层负责数据路由，分组交换和网络拥塞控制。路由器在此层下运行。 16）网络拓扑如何影响您在建立网络时的决策？ 网络拓扑决定了互连设备必须使用什么媒介。它还作为适用于设置的材料，连接器和终端的基础。 17）什么是 RIP？ RIP，路由信息协议的简称由路由器用于将数据从一个网络发送到另一个网络。 它通过将其路由表广播到网络中的所有其他路由器来有效地管理路由数据。它以跳数为单位确定网络距离。 18）什么是不同的方式来保护计算机网络？ 有几种方法可以做到这一点。在所有计算机上安装可靠和更新的防病毒程序。确保防火墙的设置和配置正确。用户认证也将有很大的帮助。所有这些组合将构成一个高度安全的网络。 19）什么是 NIC？ NIC 是网络接口卡（网卡）的缩写。这是连接到 PC 以连接到网络沈北。每个 NIC都有自己的 MAC 地址，用于标识网络上的 PC。 20）什么是 WAN？ WAN 代表广域网。它是地理上分散的计算机和设备的互连。它连接位于不同地区和国家/地区的网络。 21）OSI 物理层的重要性是什么？ 物理层进行从数据位到电信号的转换，反之亦然。这是网络设备和电缆类型的考虑和设置。 22）TCP/IP 下有多少层？ 有四层：网络层，互联网层，传输层和应用层。 23）什么是代理服务器，它们如何保护计算机网络？ 代理服务器主要防止外部用户识别内部网络的 IP 地址。不知道正确的 IP 地址，甚至无法识别网络的物理位置。代理服务器可以使外部用户几乎看不到网络。 24）OSI 会话层的功能是什么？ 该层为网络上的两个设备提供协议和方法，通过举行会话来相互通信。这包括设置会话，管理会话期间的信息交换以及终止会话时的解除过程。 25）实施容错系统的重要性是什么？有限吗？ 容错系统确保持续的数据可用性。这是通过消除单点故障来实现的。但是，在某些情况下，这种类型的系统将无法保护数据，例如意外删除。 26）10Base-T 是什么意思？ 10 是指数据传输速率，在这种情况下是 10Mbps。“Base”是指基带。T 表示双绞线，这是用于该网络的电缆。 27）什么是私有 IP 地址？ 专用 IP 地址被分配用于内部网。这些地址用于内部网络，不能在外部公共网络上路由。这些确保内部网络之间不存在任何冲突，同时私有 IP 地址的范围同样可重复使用于多个内部网络，因为它们不会“看到”彼此。 28）什么是 NOS？ NOS 或网络操作系统是专门的软件，其主要任务是向计算机提供网络连接，以便能够与其他计算机和连接的设备进行通信。 29）什么是 DoS？ DoS 或拒绝服务攻击是试图阻止用户访问互联网或任何其他网络服务。这种攻击可能有不同的形式，由一群永久者组成。这样做的一个常见方法是使系统服务器过载，使其无法再处理合法流量，并将被强制重置。 30）什么是 OSI，它在电脑网络中扮演什么角色？ OSI（开放系统互连）作为数据通信的参考模型。它由 7 层组成，每层定义了网络设备如何相互连接和通信的特定方面。一层可以处理所使用的物理介质，而另一层则指示如何通过网络实际传输数据。 31）电缆被屏蔽并具有双绞线的目的是什么？ 其主要目的是防止串扰。串扰是电磁干扰或噪声，可能影响通过电缆传输的数据。 32）地址共享的优点是什么？ 通过使用地址转换而不是路由，地址共享提供了固有的安全性优势。这是因为互联网上的主机只能看到提供地址转换的计算机上的外部接口的公共 IP 地址，而不是内部网络上的私有 IP 地址。 33）什么是 MAC 地址？ MAC 或媒介访问控制，可以唯一地标识网络上的设备。它也被称为物理地址或以太网地址。MAC 地址由 6 个字节组成。 34）在 OSI 参考模型方面，TCP/IP 应用层的等同层或多层是什么？ TCP/IP 应用层实际上在 OSI 模型上具有三个对等体：会话层，表示层和应用层。 35）如何识别给定 IP 地址的 IP 类？ 通过查看任何给定 IP 地址的第一个八位字节，您可以识别它是 A 类，B 类还是 C类。如果第一个八位字节以 0 位开头，则该地址为 Class A.如果以位 10 开头，则该地址为 B 类地址。如果从 110 开始，那么它是 C 类网络。 36）OSPF 的主要目的是什么？ OSPF 或开放最短路径优先，是使用路由表确定数据交换的最佳路径的链路状态路由协议。 37）什么是防火墙？ 防火墙用于保护内部网络免受外部攻击。这些外部威胁可能是黑客谁想要窃取数据或计算机病毒，可以立即消除数据。它还可以防止来自外部网络的其他用户访问专用网络。 38）描述星形拓扑 星形拓扑由连接到节点的中央集线器组成。这是最简单的设置和维护之一。 39）什么是网关？ 网关提供两个或多个网段之间的连接。它通常是运行网关软件并提供翻译服务的计算机。该翻译是允许不同系统在网络上通信的关键。 40）星型拓扑的缺点是什么？ 星形拓扑的一个主要缺点是，一旦中央集线器或交换机被损坏，整个网络就变得不可用了。 41）什么是 SLIP？ SLIP 或串行线路接口协议实际上是在 UNIX 早期开发的旧协议。这是用于远程访问的协议之一。 42）给出一些私有网络地址的例子。 10.0.0.0，子网掩码为 255.0.0.0 172.16.0.0，子网掩码为 255.240.0.0 192.168.0.0，子网掩码为 255.255.0.0 43）什么是 tracert？ Tracert 是一个 Windows 实用程序，可用于跟踪从路由器到目标网络的数据采集的路由。它还显示了在整个传输路由期间采用的跳数。 44）网络管理员的功能是什么？ 网络管理员有许多责任，可以总结为 3 个关键功能：安装网络，配置网络设置以及网络的维护/故障排除。 45）描述对等网络的一个缺点。 当您正在访问由网络上的某个工作站共享的资源时，该工作站的性能会降低。 46）什么是混合网络？ 混合网络是利用客户端 - 服务器和对等体系结构的网络设置。 47）什么是 DHCP？ DHCP 是动态主机配置协议的缩写。其主要任务是自动为网络上的设备分配 IP 地址。它首先检查任何设备尚未占用的下一个可用地址，然后将其分配给网络设备。 48）ARP 的主要工作是什么？ ARP 或地址解析协议的主要任务是将已知的 IP 地址映射到 MAC 层地址。 49）什么是 TCP/IP？ TCP/IP 是传输控制协议/互联网协议的缩写。这是一组协议层，旨在在不同类型的计算机网络（也称为异构网络）上进行数据交换。 50）如何使用路由器管理网络？ 路由器内置了控制台，可让您配置不同的设置，如安全和数据记录。您可以为计算机分配限制，例如允许访问的资源，或者可以浏览互联网的某一天的特定时间。 您甚至可以对整个网络中看不到的网站施加限制。 51）当您希望在不同平台（如 UNIX 系统和 Windows 服务器之间）传输文件时，可以应用什么协议？ 使用 FTP（文件传输协议）在这些不同的服务器之间进行文件传输。这是可能的，因为 FTP 是平台无关的。 52）默认网关的使用是什么？ 默认网关提供了本地网络连接到外部网络的方法。用于连接外部网络的默认网关通常是外部路由器端口的地址。 53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？ 良好的密码不仅由字母组成，还包括字母和数字的组合。结合大小写字母的密码比使用所有大写字母或全部小写字母的密码有利。密码必须不能被黑客很容易猜到，比如日期，姓名，收藏夹等等。 54）UTP 电缆的正确终止率是多少？ 非屏蔽双绞线网线的正常终止是 100 欧姆。 55）什么是 netstat？ Netstat 是一个命令行实用程序。它提供有关连接当前 TCP/IP 设置的有用信息。 56）C 类网络中的网络 ID 数量是多少？ 对于 C 类网络，可用的网络 ID 位数为 21。可能的网络 ID 数目为 2，提高到 21或 2,097,152。每个网络 ID 的主机 ID 数量为 2，增加到 8 减去 2，或 254。 57）使用长于规定长度的电缆时会发生什么？ 电缆太长会导致信号丢失。这意味着数据传输和接收将受到影响，因为信号长度下降。 58）什么常见的软件问题可能导致网络缺陷？ 软件相关问题可以是以下任何一种或其组合： 客户端服务器问题 应用程序冲突 配置错误 协议不匹配 安全问题 用户政策和权利问题 59）什么是 ICMP？ ICMP 是 Internet 控制消息协议。它为 TCP/IP 协议栈内的协议提供消息传递和通信。这也是管理由 PING 等网络工具使用的错误信息的协议。 60）什么是 Ping？ Ping 是一个实用程序，允许您检查网络上的网络设备之间的连接。您可以使用其IP 地址或设备名称（如计算机名称）ping 设备。 61）什么是点对点（P2P）？ 对等是不在服务器上回复的网络。该网络上的所有 PC 都是单独的工作站。 62）什么是 DNS？ DNS 是域名系统。该网络服务的主要功能是为 TCP/IP 地址解析提供主机名。 63）光纤与其他介质有什么优势？ 光纤的一个主要优点是不太容易受到电气干扰。它还支持更高的带宽，意味着可以发送和接收更多的数据。长距离信号降级也非常小。 64）集线器和交换机有什么区别？ 集线器充当多端口中继器。然而，随着越来越多的设备连接到它，它将无法有效地管理通过它的流量。交换机提供了一个更好的替代方案，可以提高性能，特别是在所有端口上预期有高流量时。 65）Windows RRAS 服务支持的不同网络协议是什么？ 支持三种主要的网络协议：NetBEUI，TCP/IP 和 IPX。 66）A，B 和 C 类网络中的最大网络和主机是什么？ 对于 A 类，有 126 个可能的网络和 16,777,214 个主机 对于 B 类，有 16,384 个可能的网络和 65,534 个主机 对于 C 类，有 2,097,152 个可能的网络和 254 个主机 67）直通电缆的标准颜色顺序是什么？ 橙色/白色，橙色，绿色/白色，蓝色，蓝色/白色，绿色，棕色/白色，棕色。 68）什么协议落在 TCP/IP 协议栈的应用层之下？ 以下是 TCP/IP 应用层协议：FTP，TFTP，Telnet 和 SMTP。 69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？ 是的，您可以使用一根电缆将两台计算机连接在一起。在这种情况下可以使用交叉型电缆。在这种设置中，一条电缆的数据传输引脚连接到另一条电缆的数据接收引脚，反之亦然。 70）什么是 ipconfig？ Ipconfig 是一个常用于识别网络上计算机的地址信息的实用程序。它可以显示物理地址以及 IP 地址。 71）直通和交叉电缆有什么区别？ 直通电缆用于将计算机连接到交换机，集线器或路由器。交叉电缆用于将两个类似设备连接在一起，如 PC 到 PC 或集线器到集线器。 72）什么是客户端/服务器？ 客户端/服务器是一种类型的网络，其中一个或多个计算机充当服务器。服务器提供集中的资源库，如打印机和文件。客户端是指访问服务器的工作站。 73）描述网络。 网络是指用于数据通信的计算机和外围设备之间的互连。可以使用有线电缆或通过无线链路进行网络连接。 74）将 NIC 卡从一台 PC 移动到另一台 PC 时，MAC 地址是否也被转移？ 是的，那是因为 MAC 地址是硬连线到 NIC 电路，而不是 PC。这也意味着当 NIC卡被另一个替换时，PC 可以具有不同的 MAC 地址。 75）解释聚类支持 群集支持是指网络操作系统在容错组中连接多台服务器的能力。这样做的主要目的是在一台服务器发生故障的情况下，集群中的下一个服务器将继续进行所有处理。 76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？ 必须在所有服务器和工作站上安装防病毒程序，以确保保护。这是因为个人用户可以访问任何工作站，并在插入可移动硬盘驱动器或闪存驱动器时引入计算机病毒。 77）描述以太网。 以太网是当今使用的流行网络技术之一。它是在 20 世纪 70 年代初开发的，并且基于 IEEE 中规定的规范。以太网在局域网中使用。 78）实现环形拓扑有什么缺点？ 如果网络上的一个工作站发生故障，可能会导致整个网络丢失。另一个缺点是，当需要在网络的特定部分进行调整和重新配置时，整个网络也必须被暂时关闭。 79）CSMA/CD 和 CSMA/CA 有什么区别？ CSMA/CD 或碰撞检测，每当碰撞发生时重新发送数据帧。CSMA/CA 或碰撞避免，将首先在数据传输之前广播意图发送。 80）什么是 SMTP？ SMTP 是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在 TCP/IP 协议栈上提供必要的邮件传递服务。 81）什么是组播路由？ 组播路由是一种有针对性的广播形式，将消息发送到所选择的用户组，而不是将其发送到子网上的所有用户。 82）加密在网络上的重要性是什么？ 加密是将信息转换成用户不可读的代码的过程。然后使用秘密密钥或密码将其翻译或解密回其正常可读格式。加密有助于确保中途截获的信息仍然不可读，因为用户必须具有正确的密码或密钥。 83）如何安排和显示 IP 地址？ IP 地址显示为一系列由周期或点分隔的四位十进制数字。这种安排的另一个术语是点分十进制格式。一个例子是 192.168.101.2 84）解释认证的重要性。 认证是在用户登录网络之前验证用户凭据的过程。它通常使用用户名和密码进行。这提供了限制来自网络上的有害入侵者的访问的安全手段。 85）隧道模式是什么意思？ 这是一种数据交换模式，其中两个通信计算机本身不使用 IPSec。相反，将 LAN连接到中转网络的网关创建了一个使用 IPSec 协议来保护通过它的所有通信的虚拟隧道。 86）建立 WAN 链路涉及的不同技术有哪些？ 模拟连接 - 使用常规电话线；数字连接 - 使用数字电话线；交换连接 - 使用发送方和接收方之间的多组链接来移动数据。 87）网格拓扑的一个优点是什么？ 在一个链接失败的情况下，总会有另一个链接可用。网状拓扑实际上是最容错的网络拓扑之一。 88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？ 大部分网络由硬件组成。这些领域的问题可能包括硬盘故障，NIC 损坏甚至硬件启动。不正确的硬件配置也是其中一个疑难问题。 89）可以做什么来修复信号衰减问题？ 处理这种问题的常见方法是使用中继器和集线器，因为它将有助于重新生成信号，从而防止信号丢失。检查电缆是否正确终止也是必须的。 90）动态主机配置协议如何协助网络管理？ 网络管理员不必访问每台客户端计算机来配置静态 IP 地址，而是可以应用动态主机配置协议来创建称为可以动态分配给客户端的范围的 IP 地址池。 91）解释网络概念的概况？ 配置文件是为每个用户设置的配置设置。例如，可以创建将用户置于组中的配置文件。 92）什么是 Sneakernet？ Sneakernet 被认为是最早的联网形式，其中使用可移动介质（如磁盘，磁带）物理传输数据。 93）IEEE 在计算机网络中的作用是什么？ IEEE 或电气和电子工程师学会是由电气和电子设备标准发布和管理的工程师组成的组织。这包括网络设备，网络接口，cablings 和连接器。 94）TCP/IP Internet 层下有哪些协议？ 该层管理的协议有 4 种。这些是 ICMP，IGMP，IP 和 ARP。 95）谈到网络，什么是权限？ 权限是指在网络上执行特定操作的授权许可。网络上的每个用户可以分配个人权限，具体取决于该用户必须允许的内容。 96）建立 VLAN 的一个基本要求是什么？ 需要一个 VLAN，因为在交换机级别只有一个广播域，这意味着每当新用户连接时，该信息都会传播到整个网络。交换机上的 VLAN 有助于在交换机级别创建单独的广播域。它用于安全目的。 97）什么是 IPv6？ IPv6 或 Internet 协议版本 6 被开发以替代 IPv4。目前，IPv4 正在用于控制互联网流量，但 IPv4 已经饱和。IPv6 能够克服这个限制。 98）什么是 RSA 算法？ RSA 是 Rivest-Shamir-Adleman 算法的缩写。它是目前最常用的公钥加密算法。 99）什么是网格拓扑？ 网格拓扑是一种设置，其中每个设备都直接连接到网络上的每个其他设备。因此，它要求每个设备具有至少两个网络连接。 100）100Base-FX 网络的最大段长度是多少？ 使用 100Base-FX 的网段的最大允许长度为 412 米。整个网络的最大长度为 5 公里。————————————————版权声明：本文为CSDN博主「沧海一笑-dj」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/dengjin20104042056/article/details/102999764 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://makeafree.github.io/categories/Linux/"}],"tags":[{"name":"python文件","slug":"python文件","permalink":"http://makeafree.github.io/tags/python文件/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://makeafree.github.io/categories/Linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-13T06:32:41.663Z","updated":"2019-10-13T06:32:41.663Z","comments":true,"path":"2019/10/13/hello-world/","link":"","permalink":"http://makeafree.github.io/2019/10/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[],"keywords":[]},{"title":"python文件和目录操作方法","slug":"Python文件和目录操作方法大全","date":"2019-02-19T16:00:00.000Z","updated":"2019-02-20T13:03:55.321Z","comments":true,"path":"2019/02/20/Python文件和目录操作方法大全/","link":"","permalink":"http://makeafree.github.io/2019/02/20/Python文件和目录操作方法大全/","excerpt":"","text":"[转载]python文件和目录操作方法大全（含更改文件夹下所有文件名称的实例）一、Python中对文件、文件夹操作时经常用到的os模块和shutil模块常用方法。1.得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd() 2.返回指定目录下的所有文件和目录名:os.listdir() 3.函数用来删除一个文件:os.remove() 4.删除多个目录：os.removedirs（r“c：\\python”） 5.检验给出的路径是否是一个文件：os.path.isfile() 6.检验给出的路径是否是一个目录：os.path.isdir() 7.判断是否是绝对路径：os.path.isabs() 8.检验给出的路径是否真地存:os.path.exists() 9.返回一个路径的目录名和文件名:os.path.split() eg os.path.split(‘/home/swaroop/byte/code/poem.txt’) 结果：(‘/home/swaroop/byte/code’, ‘poem.txt’) 10.分离扩展名：os.path.splitext() 11.获取路径名：os.path.dirname() 12.获取文件名：os.path.basename() 13.运行shell命令: os.system() 14.读取和设置环境变量:os.getenv() 与os.putenv() 15.给出当前平台使用的行终止符:os.linesep Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’ 16.指示你正在使用的平台：os.name 对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ 17.重命名：os.rename（old， new） 18.创建多级目录：os.makedirs（r“c：\\python\\test”） 19.创建单个目录：os.mkdir（“test”） 20.获取文件属性：os.stat（file） 21.修改文件权限与时间戳：os.chmod（file） 22.终止当前进程：os.exit（） 23.获取文件大小：os.path.getsize（filename） 二、文件操作方法大全：1.os.mknod(“test.txt”) #创建空文件 2.fp = open(“test.txt”,w) #直接打开一个文件，如果文件不存在则创建文件 3.关于open 模式： w：以写方式打开， a：以追加模式打开 (从 EOF 开始, 必要时创建新文件) r+：以读写模式打开 w+：以读写模式打开 (参见 w ) a+：以读写模式打开 (参见 a ) rb：以二进制读模式打开 wb：以二进制写模式打开 (参见 w ) ab：以二进制追加模式打开 (参见 a ) rb+：以二进制读写模式打开 (参见 r+ ) wb+：以二进制读写模式打开 (参见 w+ ) ab+：以二进制读写模式打开 (参见 a+ ) fp.read([size]) #size为读取的长度，以byte为单位 fp.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。 fp.write(str) #把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 fp.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError fp.flush() #把缓冲区的内容写入硬盘 fp.fileno() #返回一个长整型的”文件标“ fp.isatty() #文件是否是一个终端设备文件（unix系统中的） fp.tell() #返回文件操作标记的当前位置，以文件的开头为原点 fp.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。 fp.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 三、目录操作方法大全1.创建目录 os.mkdir(“file”) 2.复制文件： shutil.copyfile(“oldfile”,”newfile”) #oldfile和newfile都只能是文件 shutil.copy(“oldfile”,”newfile”) #oldfile只能是文件夹，newfile可以是文件，也可以是目标目录 3.复制文件夹： 4.shutil.copytree(“olddir”,”newdir”) #olddir和newdir都只能是目录，且newdir必须不存在 5.重命名文件（目录） os.rename(“oldname”,”newname”) #文件或目录都是使用这条命令 6.移动文件（目录） shutil.move(“oldpos”,”newpos”) 7.删除文件 os.remove(“file”) 8.删除目录 os.rmdir(“dir”) #只能删除空目录 shutil.rmtree(“dir”) #空目录、有内容的目录都可以删 9.转换目录 os.chdir(“path”) #换路径 四、文件综合操作实例 将文件夹下所有图片名称加上’_fc’ python代码: -- coding:utf-8 --import reimport osimport time #str.split(string)分割字符串 #’连接符’.join(list) 将列表组成字符串def change_name(path): global i if not os.path.isdir(path) and not os.path.isfile(path): return False if os.path.isfile(path): file_path = os.path.split(path) #分割出目录与文件 lists = file_path[1].split(‘.’) #分割出文件与文件扩展名 file_ext = lists[-1] #取出后缀名(列表切片操作) img_ext = [‘bmp’,’jpeg’,’gif’,’psd’,’png’,’jpg’] if file_ext in img_ext: os.rename(path,file_path[0]+’/‘+lists[0]+’_fc.’+file_ext) i+=1 #注意这里的i是一个陷阱 #或者 #img_ext = ‘bmp|jpeg|gif|psd|png|jpg’ #if file_ext in img_ext: # print(‘ok—‘+file_ext) elif os.path.isdir(path): for x in os.listdir(path): change_name(os.path.join(path,x)) #os.path.join()在路径处理上很有用img_dir = ‘D:\\xx\\xx\\images’ img_dir = img_dir.replace(‘\\‘,’/‘)start = time.time()i = 0change_name(img_dir)c = time.time() - startprint(‘程序运行耗时:%0.2f’%(c))print(‘总共处理了 %s 张图片’%(i))‘’’ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"python","slug":"python","permalink":"http://makeafree.github.io/categories/python/"}],"tags":[{"name":"python文件","slug":"python文件","permalink":"http://makeafree.github.io/tags/python文件/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://makeafree.github.io/categories/python/"}]}]}